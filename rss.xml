<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>haskell-servant blog</title>
        <link>http://haskell-servant.github.io</link>
        <description><![CDATA[Posts from the haskell-servant blog]]></description>
        <atom:link href="http://haskell-servant.github.io/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 12 Jul 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Why is servant a type-level DSL?</title>
    <link>http://haskell-servant.github.io/posts/2018-07-12-servant-dsl-typelevel.html</link>
    <description><![CDATA[<div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#it-all-started-with-a-problem">It all started with a problem</a></li>
<li><a href="#a-first-non-modular-attempt">A first, non-modular attempt</a></li>
<li><a href="#the-expression-problem">The Expression Problem</a></li>
<li><a href="#a-first-modular-attempt">A first modular attempt</a></li>
<li><a href="#servants-approach-simplified">Servant’s approach (simplified)</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#going-further">Going further</a></li>
</ul></div>
<hr />
<p>This post is an attempt at explaining servant’s design as an embedded domain specific language, and particularly why it <em>had to</em> be a <em>type-level</em> domain specific language, given our requirements. Along the way, we will discuss approaches for designing extensible EDSLs in Haskell and see why other simpler approaches just can’t meet the said requirements.</p>
<section id="it-all-started-with-a-problem" class="level1">
<h1>It all started with a problem</h1>
<p>Back in 2014, Sönke Hahn, Julian Arni and myself were working together in “the Haskell team” at Zalora on all sorts of projects. Many of them involved serving web applications, querying external APIs or our own services from Haskell, PHP, JS and probably a few other languages. At the time, we were using a few of the well established “web frameworks”, among which <code>scotty</code>, whenever we had to offer some service over HTTP.</p>
<p>However, writing all those functions for hitting our own webservices was a lot of manual, error-prone, tedious work. The bigger web applications got, the more tedious it became. And it had to be done once per language in which we wanted to hit the application. This could not continue.</p>
<p>For reference, this is what a simple scotty application looks like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.Text</span> (split)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Web.Scotty</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> scotty <span class="dv">8000</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  get <span class="st">&quot;/repeat/:n&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    n <span class="ot">&lt;-</span> param <span class="st">&quot;n&quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    json (replicate n n)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  post <span class="st">&quot;/message&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    msg <span class="ot">&lt;-</span> jsonData</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    json (split <span class="st">&quot;\n&quot;</span> msg)</a></code></pre></div>
<p>How could we somewhat automate the creation of one client function per endpoint of the web application? In an ideal world, we would just show this application to some program or library and it would collect all the data it needs about the overall structure of the application from the code itself, in order to produce 2 client functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- Client for the first endpoint.</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">--</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">-- The Int is the value you want to set &quot;:n&quot; to (/repeat/23, /repeat/10, ...).</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">getRepeat ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ClientMonad</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">-- Client for the second endpoint.</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co">--</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co">-- The JSON body (just a naked string) to send is the Text argument.</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ot">postMessage ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ClientMonad</span> [<span class="dt">Text</span>]</a></code></pre></div>
<p>which would do all the hard work of preparing an HTTP request for us, even taking care of JSON encoding and decoding for us. But… the entire structure of the application is just hidden in the <code>do</code> block and we just cannot programmatically access it.</p>
<p>So… this is not realistically doable. We clearly <em>need</em> to change (a little bit? a lot?) the way we write our applications, making sure we get a description of the web’s application structure (the endpoints, the part of the request they use or depend on, what they return) that we could then hand over to <em>something</em>, which would get us our client functions.</p>
<p>We will now try implementating such a web application description DSL in the most straightforward way possible.</p>
<p><em>Note:</em> We could define a DSL with an interpreter that spits out Haskell code for us (through Template Haskell or another mechanism). The result would be typed, but the <em>process</em> would not be. The translation from the DSL to the result would be untyped code, therefore easy to get wrong. As Haskell programmers, we prefer static type checking where possible. This therefore excludes Template Haskell and other code generation mechanisms.</p>
</section>
<section id="a-first-non-modular-attempt" class="level1">
<h1>A first, non-modular attempt</h1>
<p>We want to produce client functions that look like the ones above, that prepare and send HTTP requests for us by taking some pieces of data given as arguments to those functions and encoding then storing them in the right places of the request (request path for URL captures, request body, headers, etc). Let’s perhaps start simple with a data type for describing an endpoint that can be served under some path (which can contain static string fragments and captures), for a given http method, ignoring everything else for now.</p>
<p>It could look like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Method</span> <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">|</span> <span class="dt">Post</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Endpoint</span> <span class="fu">=</span> <span class="dt">Static</span> <span class="dt">String</span> <span class="dt">Endpoint</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">              <span class="fu">|</span> <span class="dt">Capture</span> <span class="dt">Endpoint</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">              <span class="fu">|</span> <span class="dt">Verb</span> <span class="dt">Method</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co">-- GET /hello/:name</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="ot">getHello ::</span> <span class="dt">Endpoint</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">getHello <span class="fu">=</span> <span class="dt">Static</span> <span class="st">&quot;hello&quot;</span> (<span class="dt">Capture</span> (<span class="dt">Verb</span> <span class="dt">Get</span>))</a></code></pre></div>
<p>and, if we want it to look a little more “servant-y”, we can define:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:&gt;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">(:&gt;) ::</span> (<span class="dt">Endpoint</span> <span class="ot">-&gt;</span> <span class="dt">Endpoint</span>) <span class="ot">-&gt;</span> <span class="dt">Endpoint</span> <span class="ot">-&gt;</span> <span class="dt">Endpoint</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">f <span class="fu">:&gt;</span> x <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">getHelloNew ::</span> <span class="dt">Endpoint</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">getHelloNew <span class="fu">=</span> <span class="dt">Static</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span> <span class="dt">Get</span></a></code></pre></div>
<p>Unlike servant though, as you can see with the type of <code>getHello</code> and <code>getHelloNew</code>, our descriptions are good old Haskell values, both of the <code>Endpoint</code> type.</p>
<p>Given those few definitions, how could we go about, say, generating links to endpoints? Well, here is a straightforward attempt.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- a link here is just a list of path components</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">-- (we ignore query parameters in this post)</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Link</span> <span class="fu">=</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">linkTo ::</span> <span class="dt">Endpoint</span> <span class="ot">-&gt;</span> <span class="dt">Link</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">linkTo (<span class="dt">Static</span> str rest) <span class="fu">=</span> str <span class="fu">:</span> linkTo rest</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">linkTo (<span class="dt">Verb</span> _method)    <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">linkTo (<span class="dt">Capture</span> rest)    <span class="fu">=</span> <span class="fu">???</span> <span class="fu">:</span> linkTo rest</a></code></pre></div>
<p>But… what should we put in place of those <code>???</code>, if anything?</p>
<p>Well, we definitely want to add <em>some</em> path component, to fill the <code>Capture</code> slot. However, by definition, a captured path fragment is not fixed, it is allowed to vary. In other words, <code>Capture :&gt; Verb Post</code> matches both <code>POST /x</code> and <code>POST /y</code>. We cannot just pick one value and hope that it is the one the user wanted. We need to take it as an argument. But what about <code>Capture :&gt; Capture :&gt; Verb Post</code>? We would need our <code>linkTo</code> function to take 2 arguments for that case. And zero additional argument for <code>Static &quot;hello&quot; :&gt; Verb Post</code>. This is quite problematic.</p>
<p>Indeed, we would like the type of <code>linkTo</code> to be <code>Endpoint -&gt; Link</code>, <code>Endpoint -&gt; String -&gt; Link</code>, <code>Endpoint -&gt; String -&gt; String -&gt; Link</code> and so on depending on what the <code>Endpoint</code> argument is. In other words, we want the return type of <code>linkTo</code> (when really seen as a function of one argument, which it is anyway) to depend on the value of type <code>Endpoint</code> it gets as input. That is, we want a type that depends on a value, i.e dependent types.</p>
<p>The alternative would be:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- linkTo assumes that the capture values are given in the same order as we want</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">-- them to appear in the url.</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">linkTo ::</span> <span class="dt">Endpoint</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Link</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">linkTo (<span class="dt">Static</span> str rest) captureValues  <span class="fu">=</span> str <span class="fu">:</span> linkTo rest captureValues</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="co">-- when there is at least one value left in the list, we use it.</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co">-- when there isn&#39;t... we error out.</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">linkTo (<span class="dt">Capture</span> rest)    (c <span class="fu">:</span> cs)       <span class="fu">=</span> c   <span class="fu">:</span> linkTo rest cs</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">linkTo (<span class="dt">Capture</span> rest)    []             <span class="fu">=</span> error <span class="st">&quot;linkTo: capture value needed but the list is empty&quot;</span> <span class="co">-- :-(</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">linkTo (<span class="dt">Verb</span> method)     _              <span class="fu">=</span> []</a></code></pre></div>
<p>This solution is very unsatisfactory, first and foremost because it is possible for it to error out if we don’t supply the right number of captures. However, it will also silently let us pass too many capture values without telling us that some of them are not used. Such a function should be total, we really don’t want an implementation that can let us down if we’re not very careful.</p>
<p>Fortunately, <a href="https://en.wikibooks.org/wiki/Haskell/GADT">GADTs</a> can help here. We could turn <code>Endpoint</code> into a GADT that tracks captures and then use some type-level computations to get the type of the link-making function from our list of captures, as well as define the link making function through typeclass instances that would go through the captures and add an argument for each of them. Request bodies, query parameters, headers? We could probably track them too, in a similar way. Or we could unify it all by basically building up and tracking actual servant API types through a <code>GADT</code> version of Endpoint’s type argument, and do some of what servant does at the type-level, with everything else at the value-level.</p>
<p>However, all those approaches have a big problem. Once you’ve made a decision, it is set in stone, in a way. Indeed, in all these approaches, if you want to extend your web app description language, you need to add a new constructor to your <code>Endpoint</code> type. You then need to handle this new constructor in all the functions that pattern match on <code>Endpoint</code> constructors since they’ve instantly become partial. Not to mention that just the act of adding a constructor requires rebuilding the entire library. You cannot explore two different directions simultaneously without breaking code, you cannot add new constructs you hadn’t thought of without touching the library, e.g just locally in a project of yours. Extensibility and modularity were central requirements as we had been bitten by the lack of them in libraries that we were using at the time.</p>
<p>Note that a GADT-based approach would work well (in addition to being more approachable) for very stable domains, and is not considered here because of the kind of flexibility we are asking for.</p>
<p>So… how do people build extensible/modular DSLs in Haskell? The next section talks about the general problem behind this and a solution that I read about that gets us halfway to servant.</p>
</section>
<section id="the-expression-problem" class="level1">
<h1>The Expression Problem</h1>
<p>To quote <a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">Phil Wadler</a>: “<em>the expression problem is a new name for an old problem. The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts)</em>”.</p>
<p>In Haskell, the standard approach to representing some domain is to define an algebraic data type for it. For a simple type of expressions with additions and integers, we usually do:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">I</span> <span class="dt">Integer</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a></code></pre></div>
<p>and proceed to write what we call “interpreters”, which in this case are just functions that take expressions as input and do something interesting with them.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">eval (<span class="dt">I</span> n)     <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">eval (<span class="dt">Add</span> a b) <span class="fu">=</span> eval a <span class="fu">+</span> eval b</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ot">prettyPrint ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">prettyPrint (<span class="dt">I</span> n) <span class="fu">=</span> show n</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">prettyPrint (<span class="dt">Add</span> a b) <span class="fu">=</span> unwords [prettyPrint a, <span class="st">&quot;+&quot;</span>, prettyPrint b]</a></code></pre></div>
<p>So, given an expression type, we can easily “add new functions over the data type”, to reuse Phil’s wording. We just write a new function. However, when the time comes to “add new cases to the data type”, this approach becomes painful. A “new case” here means a new constructor for our <code>Expr</code> data type. Let’s say we want to support multiplications too:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">I</span> <span class="dt">Integer</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a></code></pre></div>
<p>Now, we have to modify <em>every single function that patterns matches on an <code>Expr</code></em> to handle the <code>Mul</code> constructor, including our <code>eval</code> and <code>prettyPrint</code> “interpreters”. For any non-trivial domain, this becomes <em>very</em> painful, <em>very</em> quickly. Fine, so what other options are there?</p>
<p><a href="https://userpages.uni-koblenz.de/~laemmel/TheEagle/resources/pdf/xproblem1.pdf">Ralf Lämmel’s slides</a> on the topic have been of a great help for me, back when we were looking for a solution suitable to our needs. With Oleg Kiselyov, they show how we can reasonably easily (that is, in Haskell 98) achieve full extensibility in both directions (constructors and interpretations) in Haskell. It boils down to:</p>
<ul>
<li>Turn what would be a constructor into its own little data type.</li>
<li>Turn what would be a simple function that operates on the data type into a typeclass with a method.</li>
<li>Write instances of those typeclasses for the data types representing the DSL’s constructs.</li>
</ul>
<p>This effectively means that we won’t have a single type to represent all the valid “endpoint descriptions”. Instead, with this approach, we will be able to process any “reasonable” combination of “endpoint components”. The <code>Expr</code> typeclass below is exactly what lets us say what is a valid endpoint description and what isn’t. Using their approach for our expressions would look like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- our expression constructs, one data type per</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">-- constructor we had previously.</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">	<span class="co">-- integer constants</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">data</span> <span class="dt">I</span> <span class="fu">=</span> <span class="dt">I</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">-- Since we don&#39;t have an &#39;Expr&#39; type anymore, to use as a type for</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="co">-- the fields of Add, we just make them type parameters. Sometimes</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="co">-- &#39;l&#39; and &#39;r&#39; might be I, some other times they might be &#39;Add I I&#39;,</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"><span class="co">-- or &#39;Add (Add I I) I&#39;, and so on. The type reflects the recursive</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="co">-- structure.</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="kw">data</span> <span class="dt">Add</span> l r <span class="fu">=</span> <span class="dt">Add</span> l r</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="co">-- an &quot;open union&quot; to be able to describe all the</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">-- valid expression types.</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"><span class="kw">class</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="kw">instance</span> (<span class="dt">Expr</span> l, <span class="dt">Expr</span> r) <span class="ot">=&gt;</span> <span class="dt">Expr</span> (<span class="dt">Add</span> l r)</a>
<a class="sourceLine" id="cb10-19" data-line-number="19"></a>
<a class="sourceLine" id="cb10-20" data-line-number="20"><span class="co">-- our first interpretation, evaluation</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21"><span class="kw">class</span> <span class="dt">Expr</span> a <span class="ot">=&gt;</span> <span class="dt">Eval</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22"><span class="ot">  eval ::</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23"></a>
<a class="sourceLine" id="cb10-24" data-line-number="24"><span class="co">-- evaluating a constant amounts to returning it</span></a>
<a class="sourceLine" id="cb10-25" data-line-number="25"><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">I</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-26" data-line-number="26">  eval (<span class="dt">I</span> n) <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb10-27" data-line-number="27"></a>
<a class="sourceLine" id="cb10-28" data-line-number="28"><span class="co">-- if we know how to evaluate two things, we know how to evaluate</span></a>
<a class="sourceLine" id="cb10-29" data-line-number="29"><span class="co">-- their addition</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30"><span class="kw">instance</span> (<span class="dt">Eval</span> l, <span class="dt">Eval</span> r) <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">Add</span> l r) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">  eval (<span class="dt">Add</span> a b) <span class="fu">=</span> eval a <span class="fu">+</span> eval b</a>
<a class="sourceLine" id="cb10-32" data-line-number="32"></a>
<a class="sourceLine" id="cb10-33" data-line-number="33"><span class="co">-- our second interpretation, pretty printing</span></a>
<a class="sourceLine" id="cb10-34" data-line-number="34"><span class="kw">class</span> <span class="dt">Expr</span> a <span class="ot">=&gt;</span> <span class="dt">Pretty</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-35" data-line-number="35"><span class="ot">  pretty ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-36" data-line-number="36"></a>
<a class="sourceLine" id="cb10-37" data-line-number="37"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">I</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38">  pretty (<span class="dt">I</span> n) <span class="fu">=</span> show n</a>
<a class="sourceLine" id="cb10-39" data-line-number="39"></a>
<a class="sourceLine" id="cb10-40" data-line-number="40"><span class="kw">instance</span> (<span class="dt">Pretty</span> l, <span class="dt">Pretty</span> r) <span class="ot">=&gt;</span> <span class="dt">Pretty</span> (<span class="dt">Add</span> l r) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-41" data-line-number="41">  pretty (<span class="dt">Add</span> a b) <span class="fu">=</span> unwords [pretty a, <span class="st">&quot;+&quot;</span>, pretty b]</a></code></pre></div>
<p>Every constructor that we had in our previous <code>Expr</code> data type is now turned into its own little type, and every interpretation becomes a type class that all those little types are then free to provide an instance for. In fact, we do not necessarily have to supply an instance of each interpretation for all of our constructs. If we try to interpret an expression that uses a construct not supported by this interpretation, we get a type error! This is much better than calling <code>error</code> in some corner cases that should in theory not be reached… In theory. Right.</p>
<p>Anyway, if we now want to add support for multiplications, we can do:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Mul</span> l r <span class="fu">=</span> <span class="dt">Mul</span> l r</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">instance</span> (<span class="dt">Expr</span> l, <span class="dt">Expr</span> r) <span class="ot">=&gt;</span> <span class="dt">Expr</span> (<span class="dt">Mul</span> l r)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">instance</span> (<span class="dt">Eval</span> l, <span class="dt">Eval</span> r) <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">Mul</span> l r) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  eval (<span class="dt">Mul</span> a b) <span class="fu">=</span> eval a <span class="fu">*</span> eval b</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Pretty</span> l, <span class="dt">Pretty</span> r) <span class="ot">=&gt;</span> <span class="dt">Pretty</span> (<span class="dt">Mul</span> l r) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  pretty (<span class="dt">Mul</span> a b) <span class="fu">=</span> unwords [autoParens a, <span class="st">&quot;*&quot;</span>, autoParens b]</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    <span class="kw">where</span> autoParens a<span class="fu">@</span>(<span class="dt">Add</span> _ _) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> pretty a <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">          autoParens           a <span class="fu">=</span> pretty a</a></code></pre></div>
<p>We didn’t have to change any existing function, that’s great! Let’s apply this approach to a very simplified web application description “language” that we could make out of tiny building blocks (static path fragments, captures, etc).</p>
</section>
<section id="a-first-modular-attempt" class="level1">
<h1>A first modular attempt</h1>
<p>Adapting the approach from the previous section to our domain, we can give a shot at decomposing the kind of information we want to represent into a few different “constructs” (i.e data types).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">-- static path fragments</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Static</span> <span class="fu">=</span> <span class="dt">Static</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="co">-- variable path fragments (&quot;captures&quot;)</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Capture</span> <span class="fu">=</span> <span class="dt">Capture</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="co">-- HTTP method</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Method</span> <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">|</span> <span class="dt">Post</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="co">-- Leaf of a chain of :&gt;&#39;s, specifies the HTTP method</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="kw">data</span> <span class="dt">Verb</span> <span class="fu">=</span> <span class="dt">Verb</span> <span class="dt">Method</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="co">-- chain a few &quot;endpoint components&quot; with this operator,</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="co">-- all chains must be terminated with a &#39;Verb&#39; component.</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:&gt;</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="kw">data</span> a <span class="fu">:&gt;</span> b <span class="fu">=</span> a <span class="fu">:&gt;</span> b</a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17"><span class="co">-- a class to specify all the valid endpoint descriptions</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18"><span class="kw">class</span> <span class="dt">Endpoint</span> a</a>
<a class="sourceLine" id="cb12-19" data-line-number="19"></a>
<a class="sourceLine" id="cb12-20" data-line-number="20"><span class="co">-- Verb alone is one.</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Endpoint</span> <span class="dt">Verb</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22"></a>
<a class="sourceLine" id="cb12-23" data-line-number="23"><span class="co">-- if we have a valid description, sticking &#39;Static :&gt;&#39; in front of it</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24"><span class="co">-- yields another valid description.</span></a>
<a class="sourceLine" id="cb12-25" data-line-number="25"><span class="kw">instance</span> <span class="dt">Endpoint</span> rest <span class="ot">=&gt;</span> <span class="dt">Endpoint</span> (<span class="dt">Static</span> <span class="fu">:&gt;</span> rest)</a>
<a class="sourceLine" id="cb12-26" data-line-number="26"></a>
<a class="sourceLine" id="cb12-27" data-line-number="27"><span class="co">-- if we have a valid description, sticking &#39;Capture :&gt;&#39; in front of it</span></a>
<a class="sourceLine" id="cb12-28" data-line-number="28"><span class="co">-- yields another valid description.</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29"><span class="kw">instance</span> <span class="dt">Endpoint</span> rest <span class="ot">=&gt;</span> <span class="dt">Endpoint</span> (<span class="dt">Capture</span> <span class="fu">:&gt;</span> rest)</a>
<a class="sourceLine" id="cb12-30" data-line-number="30"></a>
<a class="sourceLine" id="cb12-31" data-line-number="31"><span class="co">-- GET /hello</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32">endpoint1 <span class="fu">=</span> <span class="dt">Static</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span> <span class="dt">Get</span></a></code></pre></div>
<p>OK, why not. Let’s now try to write an interpretation for generating links to endpoints like the one above. This is a lot simpler and self-contained than investigating client generation or server-side routing, while retaining many of the difficulties. The main one is that depending on what we find in the description of the endpoint, we need the type of the link-generating function to change: indeed, if we encounter <code>Capture</code>s, then the user has to supply values for them. We will let the user do that through one additional argument per Capture we encounter.</p>
<p>Let’s start with something really simple.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Link</span> <span class="fu">=</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="co">-- @renderLink [&quot;hello&quot;, &quot;world&quot;] == &quot;/hello/world&quot;@</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">renderLink ::</span> <span class="dt">Link</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">renderLink xs <span class="fu">=</span> <span class="ch">&#39;/&#39;</span> <span class="fu">:</span> intercalate <span class="ch">&#39;/&#39;</span> xs</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="kw">class</span> <span class="dt">HasLink</span> endpoint <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  <span class="co">-- return the path components</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="ot">  link ::</span> endpoint <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">HasLink</span> api <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Static</span> <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  link (<span class="dt">Static</span> s <span class="fu">:&gt;</span> api) <span class="fu">=</span> s <span class="fu">:</span> link api</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">HasLink</span> api <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15">  link (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) <span class="fu">=</span> <span class="fu">???</span> <span class="fu">:</span> link api</a>
<a class="sourceLine" id="cb13-16" data-line-number="16"></a>
<a class="sourceLine" id="cb13-17" data-line-number="17"><span class="kw">instance</span> <span class="dt">HasLink</span> <span class="dt">Verb</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">  link _ <span class="fu">=</span> []</a></code></pre></div>
<p>We should be appending something in place of those <code>???</code> there. But since <code>Capture</code> represents variable path fragments (like <code>:userid</code> in <code>/user/:userid</code>, in many web frameworks), we do not want to pick a fixed string, we would like for this string to be supplied by the caller of <code>link</code>, as stated above. Let’s introduce a slightly fancier <code>HasLink</code> class to make it seemingly “variadic”.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">class</span> <span class="dt">HasLink</span> endpoint <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">type</span> <span class="dt">LinkType</span><span class="ot"> endpoint ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">  link ::</span> endpoint <span class="ot">-&gt;</span> <span class="dt">LinkType</span> endpoint</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">HasLink</span> <span class="dt">Verb</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  <span class="kw">type</span> <span class="dt">LinkType</span> <span class="dt">Verb</span> <span class="fu">=</span> <span class="dt">Link</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">  link _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">HasLink</span> api <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Static</span> <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  <span class="kw">type</span> <span class="dt">LinkType</span> (<span class="dt">Static</span> <span class="fu">:&gt;</span> api) <span class="fu">=</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  link (<span class="dt">Static</span> s <span class="fu">:&gt;</span> api) <span class="fu">=</span> s <span class="fu">:</span> link api</a>
<a class="sourceLine" id="cb14-12" data-line-number="12"></a>
<a class="sourceLine" id="cb14-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">HasLink</span> api <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">  <span class="co">-- HERE! we introduce a String argument</span></a>
<a class="sourceLine" id="cb14-15" data-line-number="15">  <span class="kw">type</span> <span class="dt">LinkType</span> (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"></a>
<a class="sourceLine" id="cb14-17" data-line-number="17">  <span class="co">-- we expand the type of link:</span></a>
<a class="sourceLine" id="cb14-18" data-line-number="18">  <span class="co">-- link :: (Capture :&gt; api) -&gt; String -&gt; LinkType api</span></a>
<a class="sourceLine" id="cb14-19" data-line-number="19">  <span class="co">-- we see that our little `LinkType` trick there allows</span></a>
<a class="sourceLine" id="cb14-20" data-line-number="20">  <span class="co">-- link to receive arguments when appropriate</span></a>
<a class="sourceLine" id="cb14-21" data-line-number="21">  link (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) captureValue <span class="fu">=</span> captureValue <span class="fu">:</span> link api</a></code></pre></div>
<p>Looks good. Except that this does not typecheck. The problem is with the <code>Capture :&gt; api</code> and <code>Static :&gt; api</code> instances. While we know that the <code>link</code> function will eventually return a <code>Link</code>, once given arguments for all the <code>Capture</code>s, we don’t know whether there is another <code>Capture</code> later in <code>api</code>. If there is, then <code>link api</code> would have type e.g <code>String -&gt; Link</code>, and we cannot cons a <code>String</code> on top of… a function.</p>
<p>We have to be a little smarter and accumulate the path components as we go without building up the final list directly. We will be accumulating the path components in reverse order, to make the accumulation efficient, and reverse the whole list at the end to give the final <code>Link</code> (<code>= [String]</code>) value.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">link ::</span> <span class="dt">HasLink</span> endpoint <span class="ot">=&gt;</span> endpoint <span class="ot">-&gt;</span> <span class="dt">LinkType</span> endpoint</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">link e <span class="fu">=</span> link&#39; e []</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">class</span> <span class="dt">HasLink</span> endpoint <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">LinkType</span><span class="ot"> endpoint ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="ot">  link&#39; ::</span> endpoint <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">LinkType</span> endpoint</a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">HasLink</span> <span class="dt">Verb</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="kw">type</span> <span class="dt">LinkType</span> <span class="dt">Verb</span> <span class="fu">=</span> <span class="dt">Link</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">  link&#39; _ acc <span class="fu">=</span> reverse acc</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"></a>
<a class="sourceLine" id="cb15-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">HasLink</span> api <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Static</span> <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  <span class="kw">type</span> <span class="dt">LinkType</span> (<span class="dt">Static</span> <span class="fu">:&gt;</span> api) <span class="fu">=</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">  link&#39; (<span class="dt">Static</span> s <span class="fu">:&gt;</span> api) acc <span class="fu">=</span> link&#39; api (s <span class="fu">:</span> acc)</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">  <span class="co">-- we stick the static path fragment at the top of the list,</span></a>
<a class="sourceLine" id="cb15-16" data-line-number="16">  <span class="co">-- so that it appears after the rest when we reverse the list,</span></a>
<a class="sourceLine" id="cb15-17" data-line-number="17">  <span class="co">-- in the Verb instance.</span></a>
<a class="sourceLine" id="cb15-18" data-line-number="18"></a>
<a class="sourceLine" id="cb15-19" data-line-number="19"><span class="kw">instance</span> <span class="dt">HasLink</span> api <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-20" data-line-number="20">  <span class="kw">type</span> <span class="dt">LinkType</span> (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb15-21" data-line-number="21">  link&#39; (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) acc captureValue <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-22" data-line-number="22">    link&#39; api (captureValue <span class="fu">:</span> acc)</a></code></pre></div>
<p>We can finally generate links with the new approach:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- &quot;/hello&quot;</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">simpleEndpointLink <span class="fu">=</span> renderLink (link endpoint1)</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">endpoint2 <span class="fu">=</span> <span class="dt">Capture</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span> <span class="dt">Post</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="ot">linkFun2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Link</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">linkFun2 <span class="fu">=</span> link endpoint2</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">link2a <span class="fu">=</span> renderLink (linkFun2 <span class="st">&quot;foo&quot;</span>) <span class="co">-- &quot;/foo&quot;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">link2b <span class="fu">=</span> renderLink (linkFun2 <span class="st">&quot;bar&quot;</span>) <span class="co">-- &quot;/bar&quot;</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10"></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">endpoint3 <span class="fu">=</span> <span class="dt">Static</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span> <span class="dt">Get</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">link3 <span class="fu">=</span> renderLink (link endpoint3 <span class="st">&quot;x&quot;</span> <span class="st">&quot;y&quot;</span>) <span class="co">-- &quot;/hello/x/y&quot;</span></a></code></pre></div>
<p>This looks promising. Let’s now try to introduce some more types here, by allowing captures to not be specified just as simple strings, but any <code>Show</code>able type (this is terrible, but simple enough for this post). We need to modify <code>Capture</code> to track that <code>Show</code>able type we will use to specify the value of that path fragment.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Capture</span> a <span class="fu">=</span> <span class="dt">Capture</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">HasLink</span> api) <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Capture</span> a <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="co">-- HERE! we introduce an argument of type &#39;a&#39;</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">LinkType</span> (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) <span class="fu">=</span> a <span class="ot">-&gt;</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  link&#39; (<span class="dt">Capture</span> <span class="fu">:&gt;</span> api) acc captureValue <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">	link&#39; api (show captureValue <span class="fu">:</span> acc)</a></code></pre></div>
<p>We unfortunately cannot just “track” some type by storing it in a field (which is different from storing <em>a value of that type</em>). Instead we make <code>Capture</code> a clone of <code>Proxy</code> (from <code>Data.Proxy</code>) and just carry around a phantom type parameter. This is a little inconvenient as we will <em>have to</em> type annotate <em>all</em> <code>Capture</code>s (or use the <code>TypeApplications</code> language extension), but let’s roll with this approach for now.</p>
<p>Let’s now see an endpoint description using this variant of <code>Capture</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">endpoint4  <span class="fu">=</span> <span class="dt">Static</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> (<span class="dt">Capture</span><span class="ot"> ::</span> <span class="dt">Capture</span> <span class="dt">Int</span>) <span class="fu">:&gt;</span> <span class="dt">Verb</span> <span class="dt">Post</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co">-- or, with TypeApplications:</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">endpoint4&#39; <span class="fu">=</span> <span class="dt">Static</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> (<span class="dt">Capture</span> <span class="fu">@</span><span class="dt">Int</span>) <span class="fu">:&gt;</span> <span class="dt">Verb</span> <span class="dt">Post</span></a></code></pre></div>
<p>OK, interesting, why not. It does look a little bit ugly. It would look even uglier if we included the response type in <code>Verb</code>, turning it into <code>data Verb a = Verb Method</code> which would require the same kind of type annotations. And the same problem would manifest itself if we were to add all the similar types from servant (<code>ReqBody</code>, <code>QueryParam</code>, <code>Header</code>, etc). This is quite disappointing.</p>
<p>Unrelatedly, have you noticed that I have not given the type of any of our endpoint descriptions so far? This is on purpose, because those types are a little bit fancy. Fortunately, they should look familiar:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">endpoint1 ::</span> <span class="dt">Static</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">endpoint2 ::</span> <span class="dt">Capture</span> <span class="dt">String</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">endpoint3 ::</span> <span class="dt">Static</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="dt">String</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="dt">String</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">endpoint4 ::</span> <span class="dt">Static</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span></a></code></pre></div>
<p>That’s right, not only do the descriptions (which are good old haskell values) look like servant’s API types, but their types too! We can see that we are only “hiding” the strings (in static path fragments) and the HTTP method (in verbs) from the type-level.</p>
<p>Most of the other bits of information we would want to see in API descriptions will also have to be reflected at the type-level. When we consider content types for example, we have no choice but to keep track of them at the type level too, even with this design. Because we need to make sure suitable encoding/decoding instances are available for the types that will be represented with those MIME types, and this cannot be done when discovering <code>&quot;application/json&quot;</code> in a list somewhere, at runtime.</p>
<p>All in all, there is no value in keeping anything at the value level at this point. And we are already traversing a bunch of types mixed together with funny symbols and computing the type of a link making function as we go, as evidenced by the <code>HasLink</code> instances from above, so we’ve already got one foot in type-level land.</p>
<p>An important tradeoff that we are making here is that while putting more information at the type-level indeed makes things more complex, it does however give a chance to our descriptions to influence more things, including other types. This is noticeable in the last <code>HasLink</code> instance we wrote, where making <code>Capture</code> track the type the url fragment is going to be decoded to allowed us to directly make the link-making function take a value of that type, instead of a string. This is strictly more powerful and will allow us to work in a very strongly typed world and where the typechecker “writes” a whole lot of code for us.</p>
<p>Let’s bite the bullet and finally take a quick look at what servant’s type-level approach looks like.</p>
</section>
<section id="servants-approach-simplified" class="level1">
<h1>Servant’s approach (simplified)</h1>
<p>First, let me emphasize that any of the designs we have considered so far are interesting on their own and are fruitful in different ways. They were not quite good enough to meet our requirements which were, again, dictated by the projects and needs we had at work. This whole project started because we were sick of getting things wrong when manually constructing (client) or deconstructing (server) HTTP requests and so on.</p>
<p>Now, let’s write our type-level DSL. If you want a longer version of just this section, with more explanations, you may want to read <a href="https://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/">Implementing a minimal version of servant</a>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- GHC-flavoured Haskell supports type-level strings, they are the only type-level</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="co">-- entity to have kind Symbol. We will therefore just use those,</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="co">-- wrapped with &#39;Static&#39;. See the first link in the &quot;Going further&quot;</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="co">-- section if you&#39;re not familiar with type-level strings, kinds, etc.</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Static</span> (<span class="ot">str ::</span> <span class="dt">Symbol</span>)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="kw">data</span> <span class="dt">Capture</span> (<span class="ot">a ::</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="co">-- GHC-flavoured Haskell (with the DataKinds extension) supports promoting ordinary data types</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9"><span class="co">-- to kinds and their constructors to types of those kinds. See again the</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="co">-- first link in the &quot;Going further&quot; section if this is new to you.</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="co">-- In our example, this lets us parametrize Verb not by an ordinary type but by</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12"><span class="co">-- a constructor of &#39;Method&#39;. Indeed, &#39;method&#39; can only be instantiated to</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13"><span class="co">-- Get and Post.</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Method</span> <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">|</span> <span class="dt">Post</span></a>
<a class="sourceLine" id="cb20-15" data-line-number="15"><span class="kw">data</span> <span class="dt">Verb</span> (<span class="ot">method ::</span> <span class="dt">Method</span>)</a>
<a class="sourceLine" id="cb20-16" data-line-number="16"></a>
<a class="sourceLine" id="cb20-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:&gt;</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18"><span class="kw">data</span> (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="fu">:&gt;</span> (<span class="ot">b ::</span> <span class="dt">Type</span>)</a></code></pre></div>
<p>As you can see, there isn’t a single constructor in sight, all the types (but Method) are empty. And now, we proceed with the <code>HasLink</code> class. Since we don’t have any value to give to the <code>link</code> method, given that the description is now a type, we will use <code>data Proxy a = Proxy</code> to act as an intermediate between the value level, where the calls to <code>link</code> will happen, and the type level, where the descriptions live and drive the link interpretation through our typeclass instances.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">link ::</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">link api <span class="fu">=</span> link&#39; api []</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="kw">class</span> <span class="dt">HasLink</span> api <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">LinkType</span><span class="ot"> api ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="ot">  link&#39; ::</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb21-7" data-line-number="7"></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">HasLink</span> (<span class="dt">Verb</span> method) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">  <span class="kw">type</span> <span class="dt">LinkType</span> (<span class="dt">Verb</span> method) <span class="fu">=</span> <span class="dt">Link</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">  link&#39; _ acc <span class="fu">=</span> reverse acc</a>
<a class="sourceLine" id="cb21-11" data-line-number="11"></a>
<a class="sourceLine" id="cb21-12" data-line-number="12"><span class="kw">instance</span> (<span class="dt">KnownSymbol</span> str, <span class="dt">HasLink</span> api) <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Static</span> str <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">  <span class="kw">type</span> <span class="dt">LinkType</span> (<span class="dt">Static</span> str <span class="fu">:&gt;</span> api) <span class="fu">=</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb21-14" data-line-number="14"></a>
<a class="sourceLine" id="cb21-15" data-line-number="15">  <span class="co">-- we call some &quot;magic&quot; GHC function, symbolVal, to turn type-level</span></a>
<a class="sourceLine" id="cb21-16" data-line-number="16">  <span class="co">-- strings to good old value level strings, through a Proxy to</span></a>
<a class="sourceLine" id="cb21-17" data-line-number="17">  <span class="co">-- the type-level string.</span></a>
<a class="sourceLine" id="cb21-18" data-line-number="18">  link&#39; api acc <span class="fu">=</span> link&#39; (apiTail api) (str <span class="fu">:</span> acc)</a>
<a class="sourceLine" id="cb21-19" data-line-number="19">    <span class="kw">where</span> str <span class="fu">=</span> symbolVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> str)</a>
<a class="sourceLine" id="cb21-20" data-line-number="20"></a>
<a class="sourceLine" id="cb21-21" data-line-number="21"><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">HasLink</span> api) <span class="ot">=&gt;</span> <span class="dt">HasLink</span> (<span class="dt">Capture</span> a <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-22" data-line-number="22">  <span class="kw">type</span> <span class="dt">LinkType</span> (<span class="dt">Capture</span> a <span class="fu">:&gt;</span> api) <span class="fu">=</span> a <span class="ot">-&gt;</span> <span class="dt">LinkType</span> api</a>
<a class="sourceLine" id="cb21-23" data-line-number="23">  link&#39; api acc a <span class="fu">=</span> link&#39; (apiTail api) (show a <span class="fu">:</span> acc)</a>
<a class="sourceLine" id="cb21-24" data-line-number="24"></a>
<a class="sourceLine" id="cb21-25" data-line-number="25"><span class="co">-- we&#39;re just specifying a very handy type for a function</span></a>
<a class="sourceLine" id="cb21-26" data-line-number="26"><span class="co">-- that&#39;s in fact much more general (forall a b. Proxy a -&gt; Proxy b).</span></a>
<a class="sourceLine" id="cb21-27" data-line-number="27"><span class="co">-- no magic going on, we just decide that this function takes endpoint description</span></a>
<a class="sourceLine" id="cb21-28" data-line-number="28"><span class="co">-- shaped types and drops the first component.</span></a>
<a class="sourceLine" id="cb21-29" data-line-number="29"><span class="ot">apiTail ::</span> <span class="dt">Proxy</span> (a <span class="fu">:&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> b</a>
<a class="sourceLine" id="cb21-30" data-line-number="30">apiTail <span class="dt">Proxy</span> <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>It is not all that different from the code in the previous section. We can use it all as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Static</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="dt">Double</span> <span class="fu">:&gt;</span> <span class="dt">Verb</span> &#39;<span class="dt">Get</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="ot">linkFoo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Link</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">linkFoo <span class="fu">=</span> link (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Foo</span>)</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">link1,<span class="ot"> link2 ::</span> <span class="dt">Link</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">link1 <span class="fu">=</span> linkFoo <span class="dv">40</span> <span class="fl">0.1</span></a>
<a class="sourceLine" id="cb22-8" data-line-number="8">link2 <span class="fu">=</span> linkFoo <span class="dv">2987</span> <span class="fl">980.5</span></a></code></pre></div>
<p>And that’s it! The key ingredients to servant’s design are all here. If you want to read more about actually implementing server/client interpretations for the DSL, the <em>Going further</em> section has got you covered with a few relevant links.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>I hope this little tour of some of the designs we explored on our way to writing servant was useful and informative, whether from a Haskell EDSL writer perspective or for any Haskeller who has ever wondered about why the descriptions live at the type-level. The real servant libraries of course have a much richer vocabulary for describing endpoints and entire APIs, and offer many interpretations in addition to the type-safe links. But the core ideas behind the design and implementation are the same ones we progressively arrived at in this post.</p>
</section>
<section id="going-further" class="level1">
<h1>Going further</h1>
<ul>
<li><p><a href="https://arow.info/blog/posts/2015-07-10-servant-intro.html">Servant, Type Families, and Type-level Everything - A look at advanced GHC features used in Servant</a></p>
<p>I suspect this is a rather useful resource for Haskellers who haven’t yet encountered type-level programming in (GHC) Haskell.</p></li>
<li><p><a href="https://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/">Implementing a minimal version of servant</a></p>
<p>A more approchable and more narrowly focused alternative to the servant paper, which consists in implementing a very simplified version of servant, using however the same “API type” based approach for the EDSL as the real servant.</p></li>
<li><p><a href="https://alpmestan.com/servant/servant-wgp.pdf">the servant paper</a>, published at the Workshop on Generic Programming, 2015.</p></li>
<li><p><a href="https://www.informatik.uni-marburg.de/~kos/papers/gpce06.pdf">Software extensions and Integration with Type Classes</a></p>
<p>by Ralf Lämmel and Klaus Ostermann talks in greater depth than the slides about the highly modular approach to embedded domain specific languages in Haskell that we’ve seen above, and uses it on several examples.</p></li>
<li><p><a href="https://github.com/tel/serv">serv</a> and <a href="https://github.com/chpatrick/solga">solga</a> are smaller, younger and (I think) humbler relatives of servant which make slightly different choices for the DSL.</p>
<p>Somewhat relatedly, there is <a href="https://github.com/alpmestan/servant/tree/master#servant">servant-0.1</a>, which wasn’t anything like the current approach with its API types. The link leads to its README, with an example and some explanations about the approach, for the curious reader.</p></li>
</ul>
</section>

<div class="post-info">
    Posted on July 12, 2018
    
        by Alp Mestanogullari
    
</div>
]]></description>
    <pubDate>Thu, 12 Jul 2018 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2018-07-12-servant-dsl-typelevel.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>servant 0.14.1 released</title>
    <link>http://haskell-servant.github.io/posts/2018-07-05-servant-0.14.1-released.html</link>
    <description><![CDATA[<p>We’re happy to announce the minor release of <code>servant-0.14.1</code>.</p>
<ul>
<li><p>Merge in (and slightly refactor) <code>servant-generic</code> (by <a href="https://github.com/chpatrick">Patrick Chilton</a>) into <code>servant</code> (<code>Servant.API.Generic</code>), <code>servant-client-code</code> (<code>Servant.Client.Generic</code>) and <code>servant-server</code> (<code>Servant.Server.Generic</code>).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Routes</span> route <span class="fu">=</span> <span class="dt">Routes</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  {<span class="ot"> _get ::</span> route <span class="fu">:-</span> <span class="dt">Capture</span> <span class="st">&quot;id&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ,<span class="ot"> _put ::</span> route <span class="fu">:-</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Put</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">record ::</span> <span class="dt">Routes</span> <span class="dt">AsServer</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">record <span class="fu">=</span> <span class="dt">Routes</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    { _get <span class="fu">=</span> return <span class="fu">.</span> show</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    , _put <span class="fu">=</span> return <span class="fu">.</span> odd</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="ot">app ::</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">app <span class="fu">=</span> genericServe record</a></code></pre></div>
<p>See <a href="https://haskell-servant.readthedocs.io/en/release-0.14/cookbook/generic/Generic.html">the new cookbook recipe</a> for an example.</p></li>
<li><p>Deprecate <code>Servant.Utils.Links</code>, use <code>Servant.Links</code>. The <code>Servant.Utils.Links</code> module will be removed in an upcoming major release.</p></li>
<li><p><em>servant-server</em> Deprecate <code>Servant.Utils.StaticUtils</code>, use <code>Servant.Server.StaticUtils</code>. The <code>Servant.Utils.StaticUtils</code> module will be removed in an upcoming major release.</p></li>
</ul>

<div class="post-info">
    Posted on July  5, 2018
    
        by The servant team
    
</div>
]]></description>
    <pubDate>Thu, 05 Jul 2018 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2018-07-05-servant-0.14.1-released.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>servant 0.14 released</title>
    <link>http://haskell-servant.github.io/posts/2018-06-19-servant-0.14-released.html</link>
    <description><![CDATA[<div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#significant-changes">Significant changes</a></li>
<li><a href="#other-changes">Other changes</a></li>
</ul></li>
</ul></div>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>We’re happy to announce the release of <code>servant-0.14</code>. This is relatively small release, still containing some new features and breaking changes.</p>
<section id="significant-changes" class="level2">
<h2>Significant changes</h2>
<ul>
<li><p><code>Stream</code> takes a status code argument</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="st">-Stream method        framing ctype a</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="va">+Stream method status framing ctype a</span></a></code></pre></div>
<p>(<a href="https://github.com/haskell-servant/servant/pull/966">#966</a> <a href="https://github.com/haskell-servant/servant/pull/972">#972</a>)</p></li>
<li><p><code>ToStreamGenerator</code> definition changed, so it’s possible to write an instance for conduits.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="st">-class ToStreamGenerator f a where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="st">-   toStreamGenerator :: f a -&gt; StreamGenerator a</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="va">+class ToStreamGenerator a b | a -&gt; b where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="va">+   toStreamGenerator :: a -&gt; StreamGenerator b</span></a></code></pre></div>
<p>(<a href="https://github.com/haskell-servant/servant/pull/959">#959</a>)</p></li>
<li><p>Added <code>NoFraming</code> streaming strategy (<a href="https://github.com/haskell-servant/servant/pull/959">#959</a>)</p></li>
<li><p><em>servant-client-core</em> Free <code>Client</code> implementation. Useful for testing <code>HasClient</code> instances. (<a href="https://github.com/haskell-servant/servant/pull/920">#920</a>)</p></li>
<li><p><em>servant-client-core</em> Add <code>hoistClient</code> to <code>HasClient</code>. Just like <code>hoistServer</code> allows us to change the monad in which request handlers of a web application live in, we also have <code>hoistClient</code> for changing the monad in which <em>client functions</em> live. Read <a href="https://haskell-servant.readthedocs.io/en/release-0.14/tutorial/Client.html#changing-the-monad-the-client-functions-live-in">tutorial section for more information</a>. (<a href="https://github.com/haskell-servant/servant/pull/936">#936</a>)</p>
<p>If you have own combinators, you’ll need to define a new method of <code>HasClient</code> class, for example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Client</span> m (<span class="dt">MyCombinator</span> <span class="fu">:&gt;</span> api) <span class="fu">=</span> <span class="dt">MyValue</span> <span class="fu">:&gt;</span> <span class="dt">Client</span> m api</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">hoistClientMonad pm _ nt cl <span class="fu">=</span> hoistClientMonad pm (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) nt <span class="fu">.</span> cl</a></code></pre></div></li>
<li><p><em>servant</em> Add <code>safeLink' :: (Link -&gt; a) -&gt; ... -&gt; MkLink endpoint a</code>, which allows to create helpers returning something else than <code>Link</code>. (<a href="https://github.com/haskell-servant/servant/pull/968">#968</a>)</p></li>
<li><p><em>servant-server</em> File serving in polymorphic monad. i.e. Generalised types of <code>serveDirectoryFileServer</code> etc functions in <code>Servant.Utils.StaticFiles</code> (<a href="https://github.com/haskell-servant/servant/pull/953">#953</a>)</p></li>
<li><p><em>servant-server</em> <code>ReqBody</code> content type check is recoverable. This allows writing APIs like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">      <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Int</span>      <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">PlainText</span>] <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="fu">:&lt;|&gt;</span>  <span class="dt">ReqBody</span> &#39;[<span class="dt">PlainText</span>] <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">PlainText</span>] <span class="dt">Int</span></a></code></pre></div>
<p>which is useful when handlers are subtly different, for example may do less work. (<a href="https://github.com/haskell-servant/servant/pull/937">#937</a>)</p></li>
<li><p><em>servant-client</em> Add more constructors to <code>RequestBody</code>, including <code>RequestBodyStream</code>. <em>Note:</em> we are looking for http-library agnostic API, so the might change again soon. Tell us which constructors are useful for you! (<a href="https://github.com/haskell-servant/servant/pull/913">#913</a>)</p></li>
</ul>
</section>
<section id="other-changes" class="level2">
<h2>Other changes</h2>
<ul>
<li><p><code>GetHeaders</code> instances implemented without <code>OverlappingInstances</code> (<a href="https://github.com/haskell-servant/servant/pull/971">#971</a>)</p></li>
<li><p>Added tests or enabled tests (<a href="https://github.com/haskell-servant/servant/pull/975">#975</a>)</p></li>
<li><p>Add <a href="https://haskell-servant.readthedocs.io/en/release-0.14/cookbook/pagination/Pagination.html">pagination cookbook recipe</a> (<a href="https://github.com/haskell-servant/servant/pull/946">#946</a>)</p></li>
<li><p>Add <a href="https://haskell-servant.readthedocs.io/en/release-0.14/cookbook/structuring-apis/StructuringApis.html"><code>servant-flatten</code> “spice” to the structuring api recipe</a> (<a href="https://github.com/haskell-servant/servant/pull/929">#929</a>)</p></li>
<li><p>Dependency updates (<a href="https://github.com/haskell-servant/servant/pull/900">#900</a> <a href="https://github.com/haskell-servant/servant/pull/919">#919</a> <a href="https://github.com/haskell-servant/servant/pull/924">#924</a> <a href="https://github.com/haskell-servant/servant/pull/943">#943</a> <a href="https://github.com/haskell-servant/servant/pull/964">#964</a> <a href="https://github.com/haskell-servant/servant/pull/967">#967</a> <a href="https://github.com/haskell-servant/servant/pull/976">#976</a>)</p></li>
<li><p>Documentation updates <a href="https://github.com/haskell-servant/servant/pull/963">#963</a> <a href="https://github.com/haskell-servant/servant/pull/960">#960</a> <a href="https://github.com/haskell-servant/servant/pull/908">#908</a> <a href="https://github.com/haskell-servant/servant/pull/958">#958</a> <a href="https://github.com/haskell-servant/servant/pull/948">#948</a> <a href="https://github.com/haskell-servant/servant/pull/928">#928</a> <a href="https://github.com/haskell-servant/servant/pull/921">#921</a>)</p></li>
<li><p>Development process improvements (<a href="https://github.com/haskell-servant/servant/pull/680">#680</a> <a href="https://github.com/haskell-servant/servant/pull/917">#917</a> <a href="https://github.com/haskell-servant/servant/pull/923">#923</a> <a href="https://github.com/haskell-servant/servant/pull/961">#961</a> <a href="https://github.com/haskell-servant/servant/pull/973">#973</a>)</p></li>
</ul>
</section>
</section>

<div class="post-info">
    Posted on June 19, 2018
    
        by The servant team
    
</div>
]]></description>
    <pubDate>Tue, 19 Jun 2018 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2018-06-19-servant-0.14-released.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>Passing a DB connection to handlers in Servant</title>
    <link>http://haskell-servant.github.io/posts/2017-03-03-servant-and-db.html</link>
    <description><![CDATA[<p>This post is originally published in http://oleg.fi/gists/posts/2017-03-03-servant-and-db.html. This version is updated to use <code>hoistServer</code>.</p>
<p>This write-up is motivated by discussion in <a href="https://github.com/haskell-servant/servant/issues/704">servant/#704 issue</a>. I try to summarize the main points.</p>
<p>As this is a literate haskell file, we’ll need to do a small prelude dance:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Pool</span> (<span class="dt">Pool</span>, withResource)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Control.Monad.Base</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Control</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Database.PostgreSQL.Simple</span> (<span class="dt">Connection</span>)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Log</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Category</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="co">-- | Needed for &#39;MonadLog (LogT Handler)&#39; instance</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">instance</span> <span class="dt">MonadTime</span> <span class="dt">Handler</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    currentTime <span class="fu">=</span> liftIO currentTime</a></code></pre></div>
<section id="the-problem" class="level2">
<h2>The problem</h2>
<p>The issue started as instance XY-problem:</p>
<ul>
<li><strong>Y</strong>: Docs explaining how to actually create a full combinator (ex. one to create/store a DB connection)</li>
<li><strong>X</strong>: How to pass a db connection to the handlers.</li>
</ul>
<p>I won’t answer to the <strong>Y</strong>, how to write combinators is different topic (have to write about that later). Let’s see how to deal with <strong>X</strong>, by implementing a small Cat CR(UD) API:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- we should have proper data/newtypes, but then we&#39;ll need to write instances.</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- we&#39;ll try to keep a boilerplate at the minimum in this example.</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Cat</span> <span class="fu">=</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">type</span> <span class="dt">CatName</span> <span class="fu">=</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;cat&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;name&quot;</span> <span class="dt">CatName</span> <span class="fu">:&gt;</span> <span class="dt">Put</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Cat</span>  <span class="co">-- create</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cat&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;name&quot;</span> <span class="dt">CatName</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Cat</span>  <span class="co">-- read</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">api <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>Now we’ll need to implement the api, we’ll write a basic Haskell functions, which we would write anyway, we could reuse them in a console application, for example.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">createCat ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">CatName</span> <span class="ot">-&gt;</span> m <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">createCat <span class="fu">=</span> error <span class="st">&quot;not implemented&quot;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">readCat ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">CatName</span> <span class="ot">-&gt;</span> m <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">readCat <span class="fu">=</span> error <span class="st">&quot;not implemented&quot;</span></a></code></pre></div>
<p>And the problem is that if we try to do</p>
<pre class="foo"><code>-- THIS DOESN&#39;T WORK
app :: Application
app = serve api $ createCat :&lt;|&gt; readCat</code></pre>
<p>it will fail with a type-error message from GHC. Obviously, GHC cannot conjure <code>Connection</code> for us. We need to pass it in somehow.</p>
</section>
<section id="partial-application" class="level2">
<h2>Partial application</h2>
<p><em>Partial application</em> is a simple tool. We can partially apply the implementation to fit into type required by <code>serve</code>. We’ll make a situation a bit more interesting by using a connection pool:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">app ::</span> <span class="dt">Pool</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">app pool <span class="fu">=</span> serve api <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    withResource1 pool createCat <span class="fu">:&lt;|&gt;</span> withResource1 pool readCat</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">    withResource1 ::</span> <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m <span class="ot">=&gt;</span> <span class="dt">Pool</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m c</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    withResource1 pool f b <span class="fu">=</span> withResource pool <span class="fu">$</span> \a <span class="ot">-&gt;</span> f a b</a></code></pre></div>
<p>As you can see we’d need to wrap every handler in <code>withResource1</code>. It’s not very elegant, but <strong>it works</strong>. And is very <strong>simple</strong> to understand.</p>
</section>
<section id="hoistserver" class="level2">
<h2>hoistServer</h2>
<p><code>servant</code> offers the <a href="http://hackage.haskell.org/package/servant-server-0.14/docs/Servant-Server.html#v:hoistServer"><code>hoistServer</code></a> helper function. which let’s you to remove this kind of boilerplate. We’ll rewrite our handlers in MTL-style, with a <code>MonadDB</code> type class. For the sake of example let’s also add a <code>MonadLog</code> from <a href="http://hackage.haskell.org/package/log-base"><code>log-base</code></a> to the first endpoint.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">MonadDB</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    withConnection ::</span> (<span class="dt">Connection</span> <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">createCat&#39; ::</span> (<span class="dt">MonadDB</span> m, <span class="dt">MonadLog</span> m) <span class="ot">=&gt;</span> <span class="dt">CatName</span> <span class="ot">-&gt;</span> m <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">createCat&#39; <span class="fu">=</span> error <span class="st">&quot;not implemented&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ot">readCat&#39; ::</span> (<span class="dt">MonadDB</span> m) <span class="ot">=&gt;</span> <span class="dt">CatName</span> <span class="ot">-&gt;</span> m <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">readCat&#39; <span class="fu">=</span> error <span class="st">&quot;not implemented&quot;</span></a></code></pre></div>
<p>Looks good, but how we’ll pass a connection (and a logger)? The answer is obvious, when you know it: we’ll need to use a concrete monad implementation, for example:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">H</span> a <span class="fu">=</span> <span class="dt">H</span> {<span class="ot"> runH ::</span> <span class="dt">ReaderT</span> (<span class="dt">Pool</span> <span class="dt">Connection</span>) (<span class="dt">LogT</span> <span class="dt">Handler</span>) a }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">   <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadTime</span>, <span class="dt">MonadLog</span>)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">MonadDB</span> <span class="dt">H</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    withConnection f <span class="fu">=</span> <span class="dt">H</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        pool <span class="ot">&lt;-</span> ask</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        withResource pool <span class="fu">$</span> \conn <span class="ot">-&gt;</span> runH (f conn)</a></code></pre></div>
<p>And now <code>hoistServer</code> will do the magic:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">app&#39; ::</span> <span class="dt">Pool</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">app&#39; pool logger <span class="fu">=</span> serve api <span class="fu">$</span> hoistServer api nt <span class="fu">$</span> createCat&#39; <span class="fu">:&lt;|&gt;</span> readCat&#39;</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">    nt ::</span> <span class="dt">H</span> x <span class="ot">-&gt;</span> <span class="dt">Handler</span> x</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    nt m <span class="ot">-&gt;</span> runLogT <span class="st">&quot;api&quot;</span> logger (runReaderT (runH m) pool)</a></code></pre></div>
<p>The <code>nt</code> (for natural transformation) tells how to transform the concrete monad <code>H</code> into servant’s <code>Handler</code>. The <code>hoistServer</code> machinery walks through <code>ServerT H</code> value and applies that transformation, resulting into <code>ServerT Handler</code> value. If <code>api</code> has <code>HasServer</code> instance, you can <code>hoistServer</code> it.</p>
<p>The <code>hoistServer</code> is most useful when you have polymorphic handlers defined with mtl-like monad type-classes, so you can instantiate them all with the same concrete monad at then end. Note: that if we had concrete <code>LogT Handler</code> in some handler, and <code>ReaderT (Pool Connection) Handler</code> in some other one, <code>hoistServer</code> won’t help!</p>
<p>So to conclude:</p>
<ul>
<li>start with <em>partial application</em> to pass arguments into handlers</li>
<li>later you may transfer to use fancier <code>hoistServer</code>.</li>
</ul>
<p><a href="https://github.com/haskell-servant/servant/issues/704#issuecomment-283396827">Alp Mestanogullari summarised it well</a>: <em>gradually reach for fancier things as your needs grow, never when it’s not required</em>.</p>
</section>

<div class="post-info">
    Posted on March  3, 2017
    
        by Oleg Grenrus
    
</div>
]]></description>
    <pubDate>Fri, 03 Mar 2017 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2017-03-03-servant-and-db.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>servant 0.5 released</title>
    <link>http://haskell-servant.github.io/posts/2016-03-19-servant-0.5-release.html</link>
    <description><![CDATA[<div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#upgrading">Upgrading</a><ul>
<li><a href="#servant-server"><em>servant-server</em></a></li>
<li><a href="#servant-client"><em>servant-client</em></a></li>
<li><a href="#servant-docs"><em>servant-docs</em></a></li>
<li><a href="#if-you-have-your-own-combinators">If you have your own combinators</a></li>
</ul></li>
<li><a href="#major-changes">Major Changes</a><ul>
<li><a href="#trie-based-routing">Trie-based routing</a></li>
<li><a href="#proper-error-handling">Proper error handling</a></li>
<li><a href="#context-machinery"><code>Context</code> machinery</a></li>
<li><a href="#http-api-data"><code>http-api-data</code></a></li>
<li><a href="#simplify-tosample">Simplify <code>ToSample</code></a></li>
<li><a href="#unifying-method-combinators">Unifying method combinators</a></li>
<li><a href="#non-memoized-request-body">Non-memoized request body</a></li>
<li><a href="#remove-matrix-params">Remove matrix params</a></li>
<li><a href="#switch-from-eithert-to-exceptt">Switch from <code>EitherT</code> to <code>ExceptT</code></a></li>
<li><a href="#manager-and-baseurl-as-an-argument"><code>Manager</code> and <code>BaseUrl</code> as an argument</a></li>
<li><a href="#nocontent-and-status-codes"><code>NoContent</code> and status codes</a></li>
<li><a href="#servant-js">servant-js</a></li>
<li><a href="#servant-foreign">servant-foreign</a></li>
<li><a href="#auth">Auth</a><ul>
<li><a href="#basic-auth">Basic Auth</a></li>
</ul></li>
<li><a href="#documentation">Documentation</a></li>
</ul></li>
<li><a href="#release-management">Release Management</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></div>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>We’re happy to announce the release of <code>servant-0.5</code>. Quite a lot of exciting changes have happened since the last major release. A lot of things happened under the hood, but there’s also a number of changes on the surface. This will force <code>servant</code> users that want to upgrade to perform some changes to their code. Therefore the following section contains an upgrade guide. We hope, upgrading will go smoothly. At least when you didn’t write your own combinators it should be fairly straightforward.</p>
<p>The second section of this blog post contains a description of the major new features in <code>servant-0.5</code>.</p>
</section>
<section id="upgrading" class="level1">
<h1>Upgrading</h1>
<section id="servant-server" class="level2">
<h2><em>servant-server</em></h2>
<ul>
<li><p>Instead of <code>EitherT</code> (from <code>either</code>) we now use <code>ExceptT</code> (from <code>mtl</code>), which behaves the same, but doesn’t add a dependency. Your handler’s types have to change from e.g. <code>EitherT ServantErr IO MyType</code> to <code>ExceptT ServantErr IO MyType</code>. Throwing an error used to work with e.g. <code>left myError</code> and that now has to be switched to <code>throwE myError</code>. Both <code>ExceptT</code> and <code>throwE</code> reside in <code>Control.Monad.Trans.Except</code>.</p></li>
<li><p><code>Post</code> now returns 200. Replace <code>Post</code> with <code>PostCreated</code> if you want to stick to the old behaviour, which was returning a 201.</p></li>
<li><p>Methods returning <code>()</code> do not automatically return 204 anymore. Use <code>GetNoContent</code> (and <code>PostNoContent</code>, etc.) in conjunction with the <code>NoContent</code> type instead:</p></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">    <span class="co">-- Old code</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="dt">Get</span> &#39;[] ()</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="co">-- New code</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="dt">GetNoContent</span> &#39;[<span class="dt">JSON</span>] <span class="dt">NoContent</span></a></code></pre></div>
<ul>
<li><p><code>MatrixParam</code> has been removed.</p></li>
<li><p>The content-type list now is invariably used to determine whether to respond – that is, even when you’re returning <code>NoContent</code> you need to specify matching content-types.</p></li>
</ul>
</section>
<section id="servant-client" class="level2">
<h2><em>servant-client</em></h2>
<ul>
<li><p><code>client</code> now takes a <code>Manager</code> parameter. (See <a href="http://haddock.stackage.org/lts-5.8/http-client-0.4.27/Network-HTTP-Client-Internal.html#t:Manager">Manager</a>.)</p></li>
<li><p><code>MatrixParam</code> has been removed.</p></li>
</ul>
</section>
<section id="servant-docs" class="level2">
<h2><em>servant-docs</em></h2>
<ul>
<li><p><code>ToSample</code> now only takes one type parameter.</p></li>
<li><p><code>MatrixParam</code> has been removed.</p></li>
</ul>
</section>
<section id="if-you-have-your-own-combinators" class="level2">
<h2>If you have your own combinators</h2>
<p>Then the story is more complicated. The <code>HasServer</code> class changed quite drastically:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- Previously</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">class</span> <span class="dt">HasServer</span> layout config <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">   <span class="kw">type</span> <span class="dt">ServerT</span> layout (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">   route ::</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">Server</span> layout <span class="ot">-&gt;</span> <span class="dt">RoutingApplication</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">-- Now</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">class</span> <span class="dt">HasServer</span> layout config <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">   <span class="kw">type</span> <span class="dt">ServerT</span> layout (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ot">   route ::</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">Config</span> config <span class="ot">-&gt;</span> <span class="dt">Delayed</span> (<span class="dt">Server</span> layout) <span class="ot">-&gt;</span> <span class="dt">Router</span></a></code></pre></div>
<p>Read below for more information.</p>
</section>
</section>
<section id="major-changes" class="level1">
<h1>Major Changes</h1>
<section id="trie-based-routing" class="level2">
<h2>Trie-based routing</h2>
<p>Previously routing was <em>O(n)</em> in the number of routes, as we matched them sequentially (and indeed, bodies would sometimes be deserialized more than once). Andres Löh improved this by transforming the routing into a trie.</p>
</section>
<section id="proper-error-handling" class="level2">
<h2>Proper error handling</h2>
<p>One of the biggest embarassements for <code>servant</code> was the fact that in certain circumstances, the HTTP error returned was not what one would expect. For example, if a request had both the wrong method and the wrong body, the error returned would be 400 (Bad Request) rather 405 (Method Not Allowed). This was because we matched against parts of your API in the order they appeared in your API type. Andres Löh came up with an elegant solution to this problem, creating a datatype that allows checks (and their side-effects) to be delayed.</p>
<p>This allows for a fine-grained control over when side-effects and general HTTP logic is run. Currently there are five ‘slots’ for effects:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Delayed</span> c <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="dt">Delayed</span><span class="ot"> ::</span> {<span class="ot"> capturesD ::</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> captures)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">             ,<span class="ot"> methodD   ::</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> ())</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">             ,<span class="ot"> authD     ::</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> auth)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">             ,<span class="ot"> bodyD     ::</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> body)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">             ,<span class="ot"> serverD   ::</span> (captures <span class="ot">-&gt;</span> auth <span class="ot">-&gt;</span> body <span class="ot">-&gt;</span> <span class="dt">RouteResult</span> c)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">             } <span class="ot">-&gt;</span> <span class="dt">Delayed</span> c</a></code></pre></div>
<p>Which are run in the order in which they appear in the code. <a href="https://github.com/haskell-servant/servant/blob/master/servant-server/src/Servant/Server/Internal/RoutingApplication.hs#L140-L202">Helper functions</a> can be used to add more effects. In practice, this means that if you are writing a combinator for authentication, for example, you can simply use <code>addAuthCheck</code> to schedule your action. It will only be run if the captures and methods match, but before the body is looked at.</p>
<p>These five slots do not exhaust the steps of handling an HTTP request. But rather than straight away implement a very large datatype for the entire <a href="https://camo.githubusercontent.com/4e15cccf2a9277dcca2c8824092547dee7058744/68747470733a2f2f7261776769746875622e636f6d2f666f722d4745542f687474702d6465636973696f6e2d6469616772616d2f6d61737465722f6874747064642e706e67">HTTP decision diagram</a>, we decided to implement what was needed for the official <code>servant</code> combinators. We now want to gather some experience to see, if something’s missing. So if you feel like another slot is needed, open an issue!</p>
</section>
<section id="context-machinery" class="level2">
<h2><code>Context</code> machinery</h2>
<p>We had an issue that kept annoying us. Consider a <code>HasServer</code> instance for a combinator that provides a <code>User</code> by looking up the cookie in a database. You have to be able to somehow pass the lookup function – or at least a connection to a database – into that instance. But they must be passed in at run-time, and for fairly involved reasons there was no good way of doing so.</p>
<p>We added a new parameter to <code>route</code> that is an <code>HList</code> with configuration data not unlike <em>Spock</em>’s <code>Context</code>. If you are not writing <code>HasServer</code> instances, <code>Context</code> requires no changes to your code for upgrading. If you are, note that the <code>HasServer</code> type class has an extra type parameter.</p>
<p>This change should enable a variety of new combinators that were difficult or impossible previously. Note that <code>Context</code> is (for now at least) meant only for the configuration of combinator instances, not for the configuration of handlers (use <code>enter</code> for the latter).</p>
</section>
<section id="http-api-data" class="level2">
<h2><code>http-api-data</code></h2>
<p>The type classes <code>FromText</code> and <code>ToText</code> have been renamed, revamped, and relocated. They are now called <code>FromHttpApiData</code> and <code>ToHttpApiData</code> respectively, and exist in the new package <code>http-api-data</code>. This was work by Nickolay Kudasov, and includes a variety of other improvements. Most noticeably, rather than having a single [de/]serialization method, there are now ones for each of the cases for which we need the [de/]serialization. (This was based on an idea from Greg Weber.):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">class</span> <span class="dt">FromHttpApiData</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="ot">{-# MINIMAL parseUrlPiece | parseQueryParam #-}</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">    parseUrlPiece ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> a</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    parseUrlPiece <span class="fu">=</span> parseQueryParam</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">    parseHeader ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> a</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    parseHeader <span class="fu">=</span> parseUrlPiece <span class="fu">.</span> decodeUtf8</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="ot">    parseQueryParam ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> a</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    parseQueryParam <span class="fu">=</span> parseUrlPiece</a></code></pre></div>
<p>As an added bonus, the Template Haskell for <code>persistent</code> generates these automatically, making using <code>persistent</code> with <code>servant</code> a lot easier.</p>
<p>The <a href="http://hackage.haskell.org/package/http-api-data-0.2.2/docs/Web-HttpApiData.html">haddocks</a> for the package have more information.</p>
</section>
<section id="simplify-tosample" class="level2">
<h2>Simplify <code>ToSample</code></h2>
<p><code>ToSample</code> now takes only one parameter. It was an annoying mistake that it ever took two, which Nickolay Kudasov fixed. Additionally, instead of having two methods (<code>toSample</code> and <code>toSamples</code>) defined in terms of one another, we now have a single one (<code>toSamples</code>).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">MyData</span> <span class="fu">=</span> <span class="dt">MyData</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="co">-- Old code</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">MyData</span> <span class="dt">MyData</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    toSample _ <span class="fu">=</span> singleSample (<span class="dt">MyData</span> <span class="dv">42</span>)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">MyData</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    toSamples _ <span class="fu">=</span> singleSample (<span class="dt">MyData</span> <span class="dv">42</span>)</a></code></pre></div>
<p>Nickolay also made a <code>Generic</code> default method for this class, so that now you could simply have:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">MyData</span> <span class="fu">=</span> <span class="dt">MyData</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">MyData</span></a></code></pre></div>
</section>
<section id="unifying-method-combinators" class="level2">
<h2>Unifying method combinators</h2>
<p>Previously each of ‘Get’, ‘Put’, ‘Post’, etc. were entirely separate datatypes. This also meant each interpretation needed to included instances for all of them. The 0.5 release makes them instead type-synonyms, e.g.:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Get</span> contentTypes a <span class="fu">=</span> <span class="dt">Verb</span> &#39;<span class="dt">GET</span> <span class="dv">200</span> contentTypes a</a></code></pre></div>
<p>This makes it easy to change the status code of a success response. To further facilitate that, we now provide a variety of other type synonyms for responses other than 200, for example <code>PostCreated</code> for 201.</p>
</section>
<section id="non-memoized-request-body" class="level2">
<h2>Non-memoized request body</h2>
<p>Prior to Andres Löh’s trie-based routing improvements, we had to keep the request body in memory for more-or-less the duration of the request-response cycle. This was of course far from ideal, but necessary given that we could not tell whether the request might be re-routed to a different endpoint. After the changes, we can now remove it. Note however that certain idioms, such as</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">      <span class="fu">:&lt;|&gt;</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></a></code></pre></div>
<p>no longer make sense – a request body that cannot be decoded as an <code>Int</code> will be rejected with a 400, and the second endpoint will not be tried. This accords with the behaviour of more traditional frameworks and, as Edsko de Vries showed in a <a href="http://www.edsko.net/temp/dependently-typed-servers/">blog post</a>, no loss of expressivity is entailed by the change.</p>
<p>We expect this to enable streaming combinators.</p>
</section>
<section id="remove-matrix-params" class="level2">
<h2>Remove matrix params</h2>
<p>Matrix params were interacting poorly with the rest of <code>servant</code>, because they necessitate special behaviour. We decided to remove them. If you were relying on them and would like to see them back, please let us know.</p>
</section>
<section id="switch-from-eithert-to-exceptt" class="level2">
<h2>Switch from <code>EitherT</code> to <code>ExceptT</code></h2>
<p>Along with the rest of the world, we’ve moved to <code>ExceptT</code>, which is in <code>mtl</code>. Updating should consist of just replacing all occurrences of <code>EitherT</code> with <code>ExceptT</code> and all occurrences of <code>left</code> with <code>throwE</code>.</p>
</section>
<section id="manager-and-baseurl-as-an-argument" class="level2">
<h2><code>Manager</code> and <code>BaseUrl</code> as an argument</h2>
<p>Previously the <em>http-client</em> <code>Manager</code> – which is used to issue http requests – was created (with <code>unsafePerformIO</code>) by the <em>servant-client</em> library itself. This meant that it was impossible to configure the <code>Manager</code>. Now the <code>Manager</code> is passed in as an argument to client:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">-- Old code</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">endpoint1 <span class="fu">:&lt;|&gt;</span> endpoint2 <span class="fu">=</span> client api</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co">-- endpoint1 :: BaseUrl -&gt; X</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co">-- New code</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">endpoint1 <span class="fu">:&lt;|&gt;</span> endpoint2 <span class="fu">=</span> client api baseUrl manager</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="co">-- endpoint1 :: X</span></a></code></pre></div>
<p>We’re not entirely happy with this solution, since sometimes you want the <code>endpoint1</code> functions to take these two arguments instead (for example, if you would like to distribute client functions as a library). But it is certainly an improvement.</p>
</section>
<section id="nocontent-and-status-codes" class="level2">
<h2><code>NoContent</code> and status codes</h2>
<p>Previously we were much too smart about HTTP status codes. In particular, when the type of the response was <code>()</code>, we would return 204 (<code>No Content</code>). This was sometimes convenient, but generally more trouble than it was worth – some people wanted 200 codes anyhow, some people pointed out that 205 (<code>Reset Content</code>) was also often a sensible response, and moreover, <code>()</code> was too generally-used a type to convey the appropriate semantics. We now have a dedicated <code>NoContent</code> type for that, and the status code is up to you to decide (by default it will continue to be 200).</p>
<p><em>NOTE</em>: additionally, and for many of the same reasons, <code>Post</code> now returns an HTTP 200 on success (rather than 201). Use <code>PostCreated</code> if you would like the old behaviour.</p>
</section>
<section id="servant-js" class="level2">
<h2>servant-js</h2>
<p>The javascript codegen story has been considerably improved. Not only is there <code>jquery</code>-based codegen, but also <a href="https://angularjs.org/"><code>Angular</code></a>, <a href="https://github.com/mzabriskie/axios"><code>Axios</code></a> and vanilla (xhr-based) codegen. freezeboy wrote a separate post going into more details about how all of it works – stay tuned for it.</p>
<p>Furthermore, we have extracted common functionality for code-generation into <code>servant-foreign</code>. During this change, we have switched from <code>String</code> to the <code>text</code>-package. So if you were using <code>servant-jquery</code> before and are now switching to <code>servant-js</code>, take into account that we do not use the <code>String</code> datatype anymore.</p>
</section>
<section id="servant-foreign" class="level2">
<h2>servant-foreign</h2>
<p>There has been a proliferation of code-generation libraries for <code>servant</code>. With this in mind, Denis Redozubov wrote <code>servant-foreign</code> is a library purposed to address the common code-generation needs. It derives the term-level endpoints descriptions from the servant typelevel API DSL. Once you have this, it’s easy to implement code-generation for any target language. In the nutshell it allows you to generate http api clients for servant servers and incorporate that into your build/CI process. <code>servant-js</code> and some other libraries use <code>servant-foreign</code> under the hood to achieve this.</p>
</section>
<section id="auth" class="level2">
<h2>Auth</h2>
<p>One of the most drawn out discussions and PRs in <code>servant</code> has been Auth. Aaron Levin was patient enough to work through several ideas as all of us explored the design space. We currently have two auth combinators: a <code>BasicAuth</code> combinator, and a still somewhat experimental but more general <code>AuthProtect</code> combinator.</p>
<section id="basic-auth" class="level3">
<h3>Basic Auth</h3>
<p>(<em>NOTE</em>: Basic Auth sends text in the clear, so only use this over HTTPS!)</p>
<p>An API protected by Basic Auth in <code>servant</code> looks like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="dt">BasicAuth</span> <span class="st">&quot;my-realm&quot;</span> <span class="dt">User</span> <span class="fu">:&gt;</span> <span class="dt">PrivateAPI</span></a></code></pre></div>
<p>Where <code>User</code> is an application-specific datatype that your handlers will receive as an argument in case authentication succeeds.</p>
<p><code>servant</code> needs to know how to generate a <code>User</code> from a username and password string. For that, we use the new <code>Context</code> mechanism.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">serverContext ::</span> <span class="dt">Context</span> (<span class="dt">BasicAuthCheck</span> <span class="dt">User</span> &#39;<span class="fu">:</span> &#39;[])</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">serverContext <span class="fu">=</span> authCheck <span class="fu">:.</span> <span class="dt">EmptyContext</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">authCheck ::</span> <span class="dt">BasicAuthCheck</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">authCheck <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="kw">let</span> check (<span class="dt">BasicAuthData</span> username password) <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        <span class="kw">if</span> username <span class="fu">==</span> <span class="st">&quot;servant&quot;</span> <span class="fu">&amp;&amp;</span> password <span class="fu">==</span> <span class="st">&quot;server&quot;</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        <span class="kw">then</span> return (<span class="dt">Authorized</span> (<span class="dt">User</span> <span class="st">&quot;servant&quot;</span>))</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">        <span class="kw">else</span> return <span class="dt">Unauthorized</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  <span class="kw">in</span> <span class="dt">BasicAuthCheck</span> check</a></code></pre></div>
</section>
</section>
<section id="documentation" class="level2">
<h2>Documentation</h2>
<p>Sönke Hahn has done a lot of work improving our tutorial and documentation. We have moved to <a href="http://haskell-servant.readthedocs.org/">Read the Docs</a>, which should make it easy to provide documentation for multiple versions of <code>servant</code>. We have also moved towards literate Haskell, which has already improved the quality of the documentation.</p>
</section>
</section>
<section id="release-management" class="level1">
<h1>Release Management</h1>
<p><code>servant-0.5</code> was a long time in the making. We initially hoped to cut a release last summer. In the future we hope that we can move to a much more aggressive release managament. So we hope <code>servant-0.6</code> is coming soon, with a lot less changes.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>We hope you enjoy the new release. It was certainly lots of fun to work on <code>servant-0.5</code>. We’d like to say thanks to all the people that helped, big or small. Happy hacking.</p>
</section>

<div class="post-info">
    Posted on March 19, 2016
    
        by The servant team
    
</div>
]]></description>
    <pubDate>Sat, 19 Mar 2016 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2016-03-19-servant-0.5-release.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>Announcing servant-swagger and swagger2</title>
    <link>http://haskell-servant.github.io/posts/2016-02-06-servant-swagger.html</link>
    <description><![CDATA[<p><code>Servant</code> is not the first project to provide a unified way of documenting APIs. There is <code>API Blueprint</code>, <code>RAML</code>, <code>Apiary</code>, and finally <code>swagger</code>. While these Web API description languages are not also web frameworks , they are generally very mature, and have some amazing tooling. For example, take a look at what <code>swagger-ui</code>, a client-side HTML, CSS, and JS bundle, does with your <code>swagger</code> API description <a href="http://petstore.swagger.io/?url=https://gist.githubusercontent.com/fizruk/1037ddb2c81c017f4de6/raw/c4061c9655d7f0a6a51b0eebf1e16f64cc969a07/gist.swagger.json#/default">here</a>.</p>
<p>As you can see, it’s a very convenient and approachable way of exploring your API. In addition to an easily-navigable structure, you can build up requests and send them to your server, and see its responses.</p>
<p>But it doesn’t end there. If you have a <code>swagger</code> specification of your API, you can also take advantage of the large variety of <a href="https://github.com/swagger-api/swagger-codegen/blob/master/README.md#customizing-the-generator">languages</a> for which you can generate a client library automatically. You don’t even need to build the Java code - you can just use the “Generate Client” button in the beautiful <a href="http://editor.swagger.io/#/">swagger editor</a>.</p>
<p>There are a wide array of other <a href="http://swagger.io/open-source-integrations/">tools</a> that support <code>swagger</code>. Obviously, having access to them would be a great boon. The problem so far has been that writing and maintaining a <code>swagger</code> specification, that you can be sure matches your service, is hard work.</p>
<section id="swagger2-and-servant-swagger" class="level2">
<h2>swagger2 and servant-swagger</h2>
<p>Thankfully David Johnson and Nickolay Kudasov have written two Haskell libraries, <a href="https://hackage.haskell.org/package/swagger2">swagger2</a> and <a href="https://hackage.haskell.org/package/servant-swagger">servant-swagger</a>, that automate nearly all of that process for <code>servant</code> APIs. They use the mechanism that guides most of the <code>servant</code> ecosystem — interpreters for the type-level DSL for APIs that is <code>servant</code> — to generate a swagger spec for that API.</p>
<p>Let’s see how it is used; as an example, we’re going to take the Gists part of the <a href="https://developer.github.com/v3/gists/">GitHub API v3</a>. For the purpose of this post we will ignore authentication and consider only <code>GET</code> requests which do not require one. Furthermore, we’ll use simplified representation for the responses (i.e. we are also ignoring some fields of the response objects).</p>
<p>First the imports and pragmas (this is a <a href="https://github.com/haskell-servant/haskell-servant.github.io/blob/hakyll/posts/2016-02-06-servant-swagger.lhs">literate haskell file</a>):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">module</span> <span class="dt">Gists</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Control.Lens</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Aeson</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Data.Aeson.Types</span> (camelTo2)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Aeson.Types</span> <span class="kw">as</span> <span class="dt">JSON</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">BL8</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Data.HashMap.Strict</span> (<span class="dt">HashMap</span>)</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="dt">Data.Swagger</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span> <span class="dt">Data.Time</span> (<span class="dt">UTCTime</span>)</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span> <span class="dt">GHC.Generics</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span> <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="kw">import</span> <span class="dt">Servant.Swagger</span></a></code></pre></div>
<p>The API:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">GitHubGistAPI</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;username&quot;</span> <span class="dt">Username</span> <span class="fu">:&gt;</span> <span class="st">&quot;gists&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;since&quot;</span> <span class="dt">UTCTime</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] [<span class="dt">Gist</span>]</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"> <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;gists&quot;</span> <span class="fu">:&gt;</span> <span class="dt">GistsAPI</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">type</span> <span class="dt">GistsAPI</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="fu">=</span> <span class="st">&quot;public&quot;</span>  <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;since&quot;</span> <span class="dt">UTCTime</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] [<span class="dt">Gist</span>]</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"> <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;starred&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;since&quot;</span> <span class="dt">UTCTime</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] [<span class="dt">Gist</span>]</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"> <span class="fu">:&lt;|&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;id&quot;</span> <span class="dt">GistId</span> <span class="fu">:&gt;</span> <span class="dt">GistAPI</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="kw">type</span> <span class="dt">GistAPI</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    <span class="fu">=</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Gist</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"> <span class="fu">:&lt;|&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;sha&quot;</span> <span class="dt">Revision</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Gist</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">GitHubGistAPI</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">api <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>Data types:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Username</span> <span class="fu">=</span> <span class="dt">Username</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">ToText</span>, <span class="dt">FromJSON</span>)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">GistId</span> <span class="fu">=</span> <span class="dt">GistId</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">ToText</span>, <span class="dt">FromJSON</span>)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">SHA</span> <span class="fu">=</span> <span class="dt">SHA</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">ToText</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Revision</span> <span class="fu">=</span> <span class="dt">SHA</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Gist</span> <span class="fu">=</span> <span class="dt">Gist</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">  {<span class="ot"> gistId          ::</span> <span class="dt">GistId</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  ,<span class="ot"> gistDescription ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  ,<span class="ot"> gistOwner       ::</span> <span class="dt">Owner</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  ,<span class="ot"> gistFiles       ::</span> <span class="dt">HashMap</span> FilePath <span class="dt">GistFile</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  ,<span class="ot"> gistTruncated   ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">  ,<span class="ot"> gistComments    ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  ,<span class="ot"> gistCreatedAt   ::</span> <span class="dt">UTCTime</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  ,<span class="ot"> gistUpdatedAt   ::</span> <span class="dt">UTCTime</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">  } <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb3-19" data-line-number="19"></a>
<a class="sourceLine" id="cb3-20" data-line-number="20"><span class="kw">data</span> <span class="dt">OwnerType</span> <span class="fu">=</span> <span class="dt">User</span> <span class="fu">|</span> <span class="dt">Organization</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">  <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb3-22" data-line-number="22"></a>
<a class="sourceLine" id="cb3-23" data-line-number="23"><span class="kw">data</span> <span class="dt">Owner</span> <span class="fu">=</span> <span class="dt">Owner</span></a>
<a class="sourceLine" id="cb3-24" data-line-number="24">  {<span class="ot"> ownerLogin      ::</span> <span class="dt">Username</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25">  ,<span class="ot"> ownerType       ::</span> <span class="dt">OwnerType</span></a>
<a class="sourceLine" id="cb3-26" data-line-number="26">  ,<span class="ot"> ownerSiteAdmin  ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-27" data-line-number="27">  } <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb3-28" data-line-number="28"></a>
<a class="sourceLine" id="cb3-29" data-line-number="29"><span class="kw">data</span> <span class="dt">GistFile</span> <span class="fu">=</span> <span class="dt">GistFile</span></a>
<a class="sourceLine" id="cb3-30" data-line-number="30">  {<span class="ot"> gistfileSize      ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb3-31" data-line-number="31">  ,<span class="ot"> gistfileLanguage  ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-32" data-line-number="32">  ,<span class="ot"> gistfileRawUrl    ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-33" data-line-number="33">  } <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a></code></pre></div>
<p><code>FromJSON</code> instances:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">modifier ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">modifier <span class="fu">=</span> drop <span class="dv">1</span> <span class="fu">.</span> dropWhile (<span class="fu">/=</span> <span class="ch">&#39;_&#39;</span>) <span class="fu">.</span> camelTo2 <span class="ch">&#39;_&#39;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">prefixOptions ::</span> <span class="dt">JSON.Options</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">prefixOptions <span class="fu">=</span> JSON.defaultOptions { JSON.fieldLabelModifier <span class="fu">=</span> modifier }</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">OwnerType</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Owner</span>    <span class="kw">where</span> parseJSON <span class="fu">=</span> genericParseJSON prefixOptions</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">GistFile</span> <span class="kw">where</span> parseJSON <span class="fu">=</span> genericParseJSON prefixOptions</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Gist</span>     <span class="kw">where</span> parseJSON <span class="fu">=</span> genericParseJSON prefixOptions</a></code></pre></div>
<p>So far this is what you would usually have when working with <code>servant</code>. Now to generate Swagger specification we need to define schemas for our types. This is done with <code>ToParamSchema</code> and <code>ToSchema</code> instances:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">prefixSchemaOptions ::</span> <span class="dt">SchemaOptions</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">prefixSchemaOptions <span class="fu">=</span> defaultSchemaOptions { fieldLabelModifier <span class="fu">=</span> modifier }</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">ToParamSchema</span> <span class="dt">SHA</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">ToParamSchema</span> <span class="dt">Username</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">ToParamSchema</span> <span class="dt">GistId</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">ToSchema</span> <span class="dt">Username</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">ToSchema</span> <span class="dt">GistId</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">ToSchema</span> <span class="dt">OwnerType</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">ToSchema</span> <span class="dt">Owner</span>    <span class="kw">where</span> declareNamedSchema <span class="fu">=</span> genericDeclareNamedSchema prefixSchemaOptions</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">ToSchema</span> <span class="dt">GistFile</span> <span class="kw">where</span> declareNamedSchema <span class="fu">=</span> genericDeclareNamedSchema prefixSchemaOptions</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">ToSchema</span> <span class="dt">Gist</span>     <span class="kw">where</span> declareNamedSchema <span class="fu">=</span> genericDeclareNamedSchema prefixSchemaOptions</a></code></pre></div>
<p>These will give us a generically-derived Swagger schema (which is sort of a deterministic version of JSON Schema).</p>
<p>Part of the <code>swagger2</code> package, <code>Schema</code> and <code>ParamSchema</code> can be quite useful in their own right if you want to e.g. respond with a schema in case of bad request bodies, or <code>OPTIONS</code> requests.</p>
<p>The next step will traverse the <code>GitHubGistAPI</code>, gathering information about it and <code>swagger2</code> schemas to generate a <code>Swagger</code> value:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">swaggerDoc1 ::</span> <span class="dt">Swagger</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">swaggerDoc1 <span class="fu">=</span> toSwagger api</a></code></pre></div>
<p>Now we can generate the swagger documentation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">genSwaggerDoc1 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">genSwaggerDoc1 <span class="fu">=</span> BL8.putStr <span class="fu">$</span> encode swaggerDoc1</a></code></pre></div>
<p>You can attach more information to your <code>Swagger</code> doc quite easily, using the lenses provided by <code>swagger2</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">swaggerDoc2 ::</span> <span class="dt">Swagger</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">swaggerDoc2 <span class="fu">=</span> swaggerDoc1</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="fu">&amp;</span> host <span class="fu">?~</span> <span class="st">&quot;api.github.com&quot;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="fu">&amp;</span> info<span class="fu">.</span>title <span class="fu">.~</span> <span class="st">&quot;GitHub Gists API&quot;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="fu">&amp;</span> info<span class="fu">.</span>version <span class="fu">.~</span> <span class="st">&quot;v3&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">main <span class="fu">=</span> BL8.putStr <span class="fu">$</span> encode swaggerDoc2</a></code></pre></div>
<p>Which results in <a href="https://gist.githubusercontent.com/fizruk/1037ddb2c81c017f4de6/raw/c4061c9655d7f0a6a51b0eebf1e16f64cc969a07/gist.swagger.json">this</a>.</p>
<p>There’s a lot more you can do with both <code>servant-swagger</code> and <code>swagger2</code> — write manual <code>ToSchema</code> instances for more detailed information, conveniently add tags or change responses of parts of your API, use convenient lenses to modify any part of your schema, generate automatic tests, etc.</p>
<p>Check out the <a href="https://hackage.haskell.org/package/servant-swagger"><code>servant-swagger</code></a> and <a href="https://hackage.haskell.org/package/swagger2"><code>swagger2</code></a> docs for more.</p>
<p>These two new packages vastly expand the landscape of tools within easy reach of application developers using <code>servant</code>. Time to explore that landscape!</p>
<p>On a related note, Masahiro Yamauchi has recently <a href="https://github.com/swagger-api/swagger-codegen/pull/2009">added Servant codegen for Swagger</a>. So not only can you generate a swagger description for your servant server, but you can also generate the servant description from a swagger one too!</p>
</section>

<div class="post-info">
    Posted on February  6, 2016
    
        by David Johnson, Nickolay Kudasov, Julian Arni
    
</div>
]]></description>
    <pubDate>Sat, 06 Feb 2016 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2016-02-06-servant-swagger.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>Content Type Bliss</title>
    <link>http://haskell-servant.github.io/posts/2015-08-05-content-types.html</link>
    <description><![CDATA[<p>Recently I came across Timo von Holtz’s <a href="https://hackage.haskell.org/package/servant-JuicyPixels">servant-JuicyPixels</a> package. It describes <code>servant</code>-compatible content-types for JuicyPixel’s <code>DynamicImage</code> data type, and clocks under 100 airy lines.</p>
<p>Timo and I realized there is a pretty neat demonstration of the advantage of abstracting away content-type serialization and deserialization: the world’s most concise image-conversion web service. Essentially the same application is available as the <a href="https://github.com/tvh/servant-JuicyPixels/blob/master/examples/image-conversion.hs"><code>image conversion</code> example</a> in Timo’s package.</p>
<p>(If you want to know more about how content-types work in <code>servant</code>, the <a href="http://haskell-servant.github.io/tutorial/server.html#using-content-types-with-your-data-types">content-type section of the tutorial</a> has more information.)</p>
<section id="the-application" class="level1">
<h1>The Application</h1>
<p>Our goal is to provide a service that converts images between formats based on the <code>Content-Type</code> and <code>Accept</code> headers of the request:</p>
<pre class="shell"><code>$ curl localhost:8001 -H &quot;Content-Type: image/png&quot;  \
                      -H &quot;Accept: image/jpeg&quot;  \
                      --data-binary &quot;@haskell-logo.png&quot; \
                      &gt; haskell-logo.jpeg</code></pre>
<p>To get there, we need to do a couple of things. We need to of course run the application:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">main <span class="fu">=</span> run <span class="dv">8001</span> conversion</a></code></pre></div>
<p>And describe the API:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ConversionApi</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">     <span class="fu">=</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">BMP</span>, <span class="dt">GIF</span>, <span class="dt">JPEG</span> <span class="dv">50</span>, <span class="dt">PNG</span>, <span class="dt">TIFF</span>, <span class="dt">RADIANCE</span>] <span class="dt">DynamicImage</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="fu">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">BMP</span>, <span class="dt">GIF</span>, <span class="dt">JPEG</span> <span class="dv">50</span>, <span class="dt">PNG</span>, <span class="dt">TIFF</span>, <span class="dt">RADIANCE</span>] <span class="dt">DynamicImage</span></a></code></pre></div>
<p>As you can see, we state that we accept and can return a variety of image formats.</p>
<p>The application is then:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">conversion ::</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">conversion <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">ConversionApi</span>) handler</a></code></pre></div>
<p>And for the clincher, the handler:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">    <span class="kw">where</span> handler <span class="fu">=</span> return</a></code></pre></div>
<p>And that’s it!</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>This is just the limit of the relative gain of abstracting content-types - there is nothing to the application besides them!</p>
<p>Essentially the same idea could of course be applied to other areas. Document conversion with Pandoc, video and audio formats, etc.</p>
</section>

<div class="post-info">
    Posted on August  5, 2015
    
        by Julian K. Arni
    
</div>
]]></description>
    <pubDate>Wed, 05 Aug 2015 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2015-08-05-content-types.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>Pulling a mock server for your APIs out of thin air</title>
    <link>http://haskell-servant.github.io/posts/2015-07-24-pulling-mock-servers-out-of-thin-air.html</link>
    <description><![CDATA[<div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#the-problem">The Problem</a></li>
<li><a href="#the-plan">The Plan</a></li>
<li><a href="#hasmock-instances"><code>HasMock</code> instances</a></li>
<li><a href="#using-mock">Using <code>mock</code></a></li>
<li><a href="#other-news">Other news</a></li>
</ul></div>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>A couple of days ago, <em>marcushg</em> mentioned on the <strong>#servant</strong> IRC channel that one could probably easily use the information available from API types to “derive” a mock implementation of your request handlers that just generates random values of whatever the return type of the handlers are. Julian and I discussed this a bit today and I just went ahead and wrote down our thoughts in a new branch. The result will be explained in this post, but in short, it lets us take a type describing a web API, such as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">User</span></a></code></pre></div>
<p>and generate request handlers that just respond with random values of the appropriate type, <code>User</code> in our case. In <em>servant</em>/<em>wai</em> terms, this means we get a <code>mock</code> function with the type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">mock ::</span> <span class="dt">HasMock</span> api <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> <span class="dt">Server</span> api</a></code></pre></div>
<p>i.e., “given an API type, please generate a mock server for such an API”. This effectively means “please pull a mock server out of thin air for me”.</p>
<p>Out of thin air, really? Not exactly. But let’s start by clearly stating the problem.</p>
</section>
<section id="the-problem" class="level1">
<h1>The Problem</h1>
<p><em>servant</em> lets you describe web applications with a Haskell type using the combinators from servant’s type-level EDSL. Such a type would be:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- In English:</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- the API has one endpoint, under /user, which returns</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">-- response bodies in JSON that describe values of type User</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">User</span></a></code></pre></div>
<p>where <code>User</code> could be defined as:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span> {<span class="ot"> username ::</span> <span class="dt">String</span> }</a></code></pre></div>
<p>The goal would be to “automagically” derive a request handler of the right type that we could use as a placeholder until we properly implement a handler that talks to the database and responds with “the real data”.</p>
<p>For anyone not familiar with <em>servant</em> already, you just need to know that it means we need to somehow automatically implement a computation with the type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">getUser ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">User</span></a></code></pre></div>
<p>possibly by constraining the user to provide an instance for some random generation class.</p>
</section>
<section id="the-plan" class="level1">
<h1>The Plan</h1>
<p>Just like <em>servant-server</em>, <em>servant-client</em> and others, we need a class whose instances will define the way we interpret each combinator, in a way very specific to this task: we will produce what <em>servant-server</em> takes as input, i.e., request handlers! This all means we are basically looking at a class like:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">HasServer</span> api <span class="ot">=&gt;</span> <span class="dt">HasMock</span> api <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">  mock ::</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> <span class="dt">Server</span> api</a></code></pre></div>
<p>where <code>Server api</code> just computes the types of the all the request handlers of an <em>API type</em>. In our case, <code>Server api</code> is computed as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">-- api = the API type from above in our case</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="dt">Server</span> <span class="dt">API</span> <span class="fu">=</span> <span class="dt">Server</span> (<span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">User</span>)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">           <span class="co">-- static strings in the path do not influence</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">           <span class="co">-- the type of a handler</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">           <span class="fu">=</span> <span class="dt">Server</span> (<span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">User</span>)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">           <span class="co">-- EitherT ServantErr IO is the default monad</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">           <span class="co">-- in which handlers run</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">           <span class="fu">=</span> <span class="dt">Either</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">User</span></a></code></pre></div>
<p>So we have to implement at least support for static string fragments in the path and the <code>Get</code> combinator (i.e handlers for HTTP GET requests).</p>
</section>
<section id="hasmock-instances" class="level1">
<h1><code>HasMock</code> instances</h1>
<p>Let’s start with the one for static path fragments, it’s the simplest one: we ignore the string bit and move on to what comes after.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">KnownSymbol</span> path, <span class="dt">HasMock</span> rest) <span class="ot">=&gt;</span> <span class="dt">HasMock</span> (path <span class="fu">:&gt;</span> rest) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  mock _ <span class="fu">=</span> mock (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> rest)</a></code></pre></div>
<p>Don’t be scared by <code>KnownSymbol</code>, it basically just means “<code>path</code> is a type-level string”, that is, a string that appears in a type.</p>
<p>Next comes the one for <code>Get</code>. This one is trickier: this is the combinator that says what type the handler returns. The returned value then gets encoded into JSON, HTML, CSV or any format of your choice. In our case, the handler returns a <code>User</code> and can only encode it in the JSON format.</p>
<p>Now the heart of the matter really is: we know we need to return an <code>User</code> and our <code>EitherT ServantErr IO</code> monad mentions <code>IO</code>, couldn’t we randomly generate an <code>User</code>? Yes, we can! For the purpose of a mock server, we will simply use <a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a>’s <code>Arbitrary</code> class, which represents types for which we can generate random values, given a random number generator.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="co">-- and another method, but optional</span></a></code></pre></div>
<p>The <code>Gen</code> type provides instances for the <code>Functor</code>, <code>Applicative</code> and <code>Monad</code> classes and <code>Arbitrary</code> comes with instances for many of the types in <em>base</em>.</p>
<p>This essentially means writing an <code>Arbitrary</code> instance for <code>User</code> is as simple as:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">User</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="co">-- we just rely on the arbitrary instance for lists of</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="co">-- chars, i.e., Strings, and use the Functor instance for Gen</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  arbitrary <span class="fu">=</span> fmap <span class="dt">User</span> arbitrary</a></code></pre></div>
<p>If you have multiple fields, you can use the usual combo of <code>&lt;$&gt;</code> (i.e., <code>fmap</code>) and <code>&lt;*&gt;</code> (comes with <code>Applicative</code>).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">-- a point: x, y coordinates</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> <span class="dt">Double</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Point</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  arbitrary <span class="fu">=</span> <span class="dt">Point</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> arbitrary</a></code></pre></div>
<p>Once you have an <code>Arbitrary</code> instance, in order to generate a random value using your instance, you have to call a function called… <code>generate</code>!</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">generate ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a></code></pre></div>
<p>Putting the two together, we get:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">generate<span class="ot"> arbitrary ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">IO</span> a</a></code></pre></div>
<p>All we need to do is just “lift” that up into our <code>EitherT ServantErr IO</code> monad, which is exactly what <code>Control.Monad.IO.Class.liftIO</code> is about in the <a href="http://hackage.haskell.org/package/transformers">transformers</a> package.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">liftIO (generate arbitrary)<span class="ot"> ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> a</a></code></pre></div>
<p>In order to automatically “fill” request handlers with this expression we just need to write the <code>HasMock</code> instance for <code>Get</code>, shown below.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">AllCTRender</span> ctypes a) <span class="ot">=&gt;</span> <span class="dt">HasMock</span> (<span class="dt">Get</span> ctypes a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  mock _ <span class="fu">=</span> liftIO (generate arbitrary)</a></code></pre></div>
<p>The <code>AllCTRender</code> constraint just says “we know how to encode values of type <code>a</code> in the formats listed in the <code>Get</code> combinator”.</p>
<p>And that’s it! You can now actually use all of this to put together a mock server for our little API.</p>
</section>
<section id="using-mock" class="level1">
<h1>Using <code>mock</code></h1>
<p>All we need to do to run the mock server is call <em>servant-server</em>’s <code>serve</code> function. It is illustrated below, along with <strong>all</strong> of the code you’d have to write if you were to use this mock-generation feature (aside from language pragmas and imports).</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- 1/ define our user type, deriving the Arbitrary instance</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co">--    since it&#39;s just a newtype and we can use the</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="co">--    GeneralizedNewtypeDeriving extension. We also</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="co">--    derive the Generic class to get our JSON encoding</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="co">--    functions for free.</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span> {<span class="ot"> username ::</span> <span class="dt">String</span> }</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  <span class="kw">deriving</span> (<span class="dt">Arbitrary</span>, <span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="co">-- 2/ we get the JSON encoding for free</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Generic</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"></a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="co">-- 3/ recall our API type</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">User</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14"></a>
<a class="sourceLine" id="cb16-15" data-line-number="15"><span class="co">-- 4/ define this simple Proxy.</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16"><span class="co">-- for any given type &#39;a&#39;, there&#39;s only one value of type &#39;Proxy a&#39;</span></a>
<a class="sourceLine" id="cb16-17" data-line-number="17"><span class="co">-- that is not equivalent to error &quot;foo&quot; and the likes, a real honest value.</span></a>
<a class="sourceLine" id="cb16-18" data-line-number="18"><span class="co">-- The way to build this value is to use the Proxy constructor.</span></a>
<a class="sourceLine" id="cb16-19" data-line-number="19"><span class="co">-- In other words, this value lets us target one precise type. Servant</span></a>
<a class="sourceLine" id="cb16-20" data-line-number="20"><span class="co">-- uses this to tie the type-level information with value-level data.</span></a>
<a class="sourceLine" id="cb16-21" data-line-number="21"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb16-22" data-line-number="22">api <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb16-23" data-line-number="23"></a>
<a class="sourceLine" id="cb16-24" data-line-number="24"><span class="co">-- 5/ we magically derive the mock server.</span></a>
<a class="sourceLine" id="cb16-25" data-line-number="25"><span class="co">-- the run function comes from the warp webserver,</span></a>
<a class="sourceLine" id="cb16-26" data-line-number="26"><span class="co">-- http://hackage.haskell.org/package/warp</span></a>
<a class="sourceLine" id="cb16-27" data-line-number="27"><span class="co">-- &#39;mock&#39; is the method of the `HasMock` class we&#39;ve</span></a>
<a class="sourceLine" id="cb16-28" data-line-number="28"><span class="co">-- developed in this post.</span></a>
<a class="sourceLine" id="cb16-29" data-line-number="29"><span class="co">-- This will run a mock web server with an endpoint at</span></a>
<a class="sourceLine" id="cb16-30" data-line-number="30"><span class="co">-- http://localhost:8080/user that generates random values</span></a>
<a class="sourceLine" id="cb16-31" data-line-number="31"><span class="co">-- of type User</span></a>
<a class="sourceLine" id="cb16-32" data-line-number="32"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-33" data-line-number="33">main <span class="fu">=</span> run <span class="dv">8080</span> (serve api <span class="fu">$</span> mock api)</a></code></pre></div>
<p>Our little program in action:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" data-line-number="1">$ <span class="ex">curl</span> localhost:8080/user</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="dt">{&quot;username&quot;:&quot;Yv\rG\u0014±Ssv\u001e&gt;\u001aVF\u001e\u000fM5ø\u000ctefÚJ\u0001K4&quot;}</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="co"># yes, a truly original username.</span></a></code></pre></div>
<p>This is really all you have to do to put together a mock server for an API type. You can find the complete code for this in the work-in-progress <a href="https://github.com/haskell-servant/servant/tree/master/servant-mock">servant-mock</a> package on github. The example can be found under <code>example/main.hs</code> there.</p>
<p>There are many more <code>HasMock</code> instances than the ones I have shown here of course – there’s one for all the combinators provided by the <em>servant</em> package! So you can take any API type out there and just create a mock server for it, as long as you provide <code>Arbitrary</code> instances for your data types. Nothing too interesting though, but feel free to take a look at <code>src/Servant/Mock.hs</code> in the repository if you want to read the other instances.</p>
<p>I hope this makes clear how simple writing your own servant interpretation can be, and encourages you to try your hand at it!</p>
</section>
<section id="other-news" class="level1">
<h1>Other news</h1>
<ul>
<li>I mentioned in <a href="https://haskell-servant.github.io/posts/2015-05-25-servant-paper-wgp-2015.html">a previous post</a> that we had submitted a paper for the <em>Workshop on Generic Programming</em>, co-located with ICFP’15, in Vancouver this year. Well, the paper has been accepted!</li>
<li>Therefore, Julian Arni and/or Andres Löh will be giving a talk about servant there.</li>
<li>In addition to this, Julian Arni recently gave a talk about servant at <a href="http://www.curry-on.org/">Curry-On!</a>. The video will be uploaded on <a href="https://www.youtube.com/channel/UC-WICcSW1k3HsScuXxDrp0w">their Youtube channel</a> in the upcoming days.</li>
<li>I have submitted a very hands-on servant talk proposal for <a href="https://skillsmatter.com/conferences/7069-haskell-exchange-2015">the Haskell eXchange 2015</a> in London, and it has been accepted! See you there, folks.</li>
</ul>
</section>

<div class="post-info">
    Posted on July 24, 2015
    
        by Alp Mestanogullari
    
</div>
]]></description>
    <pubDate>Fri, 24 Jul 2015 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2015-07-24-pulling-mock-servers-out-of-thin-air.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>servant paper submitted to WGP 2015</title>
    <link>http://haskell-servant.github.io/posts/2015-05-25-servant-paper-wgp-2015.html</link>
    <description><![CDATA[<p>Sönke Hahn, Julian Arni, Andres Löh and myself have submitted a paper about <em>servant</em> to the <a href="http://www.wgp-sigplan.org/farmer/doku.php?id=2015">11th ACM SIGPLAN Workshop on Generic Programming</a>. Here’s the abstract.</p>
<blockquote>
<p>We describe the design and motivation for Servant, an extensible, type-level DSL for describing Web APIs. Servant APIs are Haskell types. An API type can be interpreted in several different ways: as a server that processes requests, interprets them and dispatches them to appropriate handlers; as a client that can correctly query the endpoints of the API; as systematic documentation for the API; and more. Servant is fully extensible: the API language can be augmented with new constructs, and new interpretations can be defined. The key Haskell features making all this possible are data kinds, (open) type families and (open) type classes. The techniques we use are reminiscent of general-purpose generic programming. However, where most generic programming libraries are interested in automatically deriving programs for a large class of datatypes from many different domains, we are only interested in a small class of datatypes that is used in the DSL for describing APIs.</p>
</blockquote>
<p>The full draft is available <a href="http://alpmestan.com/servant/servant-wgp.pdf">here</a>.</p>

<div class="post-info">
    Posted on May 25, 2015
    
        by Alp Mestanogullari
    
</div>
]]></description>
    <pubDate>Mon, 25 May 2015 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2015-05-25-servant-paper-wgp-2015.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>
<item>
    <title>servant 0.4 released</title>
    <link>http://haskell-servant.github.io/posts/2015-05-10-servant-0.4-released.html</link>
    <description><![CDATA[<div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#multiple-content-type-support">Multiple content-type support</a></li>
<li><a href="#servant-blaze-and-servant-lucid"><em>servant-blaze</em> and <em>servant-lucid</em></a></li>
<li><a href="#response-headers">Response headers</a></li>
<li><a href="#running-handlers-in-other-monads-than-eithert">Running handlers in other monads than <code>EitherT</code></a></li>
<li><a href="#mklink">mkLink</a></li>
<li><a href="#left">Left</a></li>
<li><a href="#baseurl">BaseUrl</a></li>
<li><a href="#complete-changelogs">Complete CHANGELOGs</a></li>
<li><a href="#website">Website</a></li>
<li><a href="#conclusions">Conclusions</a></li>
</ul></div>
<p>Since <a href="http://alpmestan.com/posts/2014-12-09-rethinking-webservices-apis-haskell.html">the last major release</a>, a lot happened in and around <em>servant</em>. Definitely enough to justify a new release. This post announces new releases of all the servant packages, with many local changes but also some major ones that affect all packages. You can find the detailed changelogs at the end of this post, but here are a few major features you may want to learn about. This website also features a <a href="/tutorial">new tutorial</a> that explains how to use <em>servant</em> from scratch.</p>
<section id="multiple-content-type-support" class="level1">
<h1>Multiple content-type support</h1>
<p><em>servant</em> combinators are not JSON-centric anymore.</p>
<p>If you had an API type like the following with servant <em>0.2.x</em>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="co">-- list users</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">           <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">           <span class="co">-- update an user</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;username&quot;</span> <span class="dt">Text</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> <span class="dt">User</span> <span class="fu">:&gt;</span> <span class="dt">Put</span> ()</a></code></pre></div>
<p>You now have to change it to:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="co">-- list users</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">           <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;username&quot;</span> <span class="dt">Text</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">User</span> <span class="fu">:&gt;</span> <span class="dt">Put</span> &#39;[<span class="dt">JSON</span>] ()</a></code></pre></div>
<p>Wherever applicable (i.e., <code>ReqBody</code> and all the combinators that correspond to an HTTP method), you can now specify all the content types in which you want to want to be able to encode/decode values. As you can see, we use the <code>DataKinds</code> GHC extension to let you specify a type-level list of content-types, which are simple dummy types:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">JSON</span></a></code></pre></div>
<p>In <em>servant-server</em>, a list of these content-types as the first argument of a method gets translated into a set of constraints on the return type:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="dt">Get</span> &#39;[<span class="dt">JSON</span>, <span class="dt">PlainText</span>] <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="fu">==&gt;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dt">MimeRender</span> <span class="dt">JSON</span> <span class="dt">Int</span>, <span class="dt">MimeRender</span> <span class="dt">PlainText</span> <span class="dt">Int</span> <span class="ot">=&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">Int</span></a></code></pre></div>
<p>Which have unsurprising instances:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">ToJSON</span> a) <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> <span class="dt">JSON</span> a</a></code></pre></div>
<p>Thus, <em>servant</em> checks at <em>compile-time</em> that it really can serialize your values as you describe. And of course, it handles picking the appropriate serialization format based on the request’s “Accept” header for you.</p>
<p>(For <code>ReqBody</code>, <em>deserialization</em> is involved. For <em>servant-client</em>, the logic goes the other way around - serialization for <code>ReqBody</code>, deserialization for methods.)</p>
</section>
<section id="servant-blaze-and-servant-lucid" class="level1">
<h1><em>servant-blaze</em> and <em>servant-lucid</em></h1>
<p>Declaring new content-types, and the associated constraints for them, is quite easy. But to make it easier still, we are also announcing two new packages: servant-blaze and servant-lucid. To use them, just import their <code>HTML</code> datatype:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Servant.HTML.Lucid</span> (<span class="dt">HTML</span>) <span class="co">-- or Servant.HTML.Blaze</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">type</span> <span class="dt">MyHTML</span> <span class="fu">=</span> <span class="dt">Get</span> &#39;[<span class="dt">HTML</span>] <span class="dt">User</span></a></code></pre></div>
<p>And <code>User</code> will be checked for the appropriate (e.g. <code>ToHtml</code>) instance.</p>
</section>
<section id="response-headers" class="level1">
<h1>Response headers</h1>
<p>There was no easy way so far to have handlers add headers to a response. We’ve since come up with a solution that stays true to the <em>servant</em> spirit: <em>what</em> headers your response will include (and what their types are) is still enforced statically:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">type</span> <span class="dt">MyHandler</span> <span class="fu">=</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] (<span class="dt">Headers</span> &#39;[<span class="dt">Header</span> <span class="st">&quot;Location&quot;</span> <span class="dt">Link</span>] <span class="dt">User</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">myHandler ::</span> <span class="dt">Server</span> <span class="dt">MyHandler</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">myHandler <span class="fu">=</span> return <span class="fu">$</span> addHeader <span class="fu">&lt;</span>someLink<span class="fu">&gt;</span> <span class="fu">$</span> <span class="fu">&lt;</span>someuser<span class="fu">&gt;</span></a></code></pre></div>
<p><em>servant-docs</em> and <em>servant-client</em> are also response-header aware.</p>
<p>Our current solution isn’t something we are entirely happy with from an internal persepctive. We use overlapping instances for all the handlers, which some might think is already a problem. But more concretely, there’s the threat of an exponential blowup in the number of instances we have to declare. And that can be a problem for end users too, if they decide to further modify behavior via a similar mechanism. But these things thankfully don’t seem to pose any <em>immediate</em> problems.</p>
</section>
<section id="running-handlers-in-other-monads-than-eithert" class="level1">
<h1>Running handlers in other monads than <code>EitherT</code></h1>
<p>An often-requested feature has been easy use of datatypes/monads besides <code>EitherT</code>. Now we believe we have a good story for that (thanks in large part to <a href="http://github.com/rschatz">rschatz</a>). To convert from one datatype to another, all you need to do is provide a natural transformation between them. For example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ReaderAPI</span> <span class="fu">=</span> <span class="st">&quot;a&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">            <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;b&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">readerServerT ::</span> <span class="dt">ServerT</span> <span class="dt">ReaderAPI</span> (<span class="dt">Reader</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">readerServerT <span class="fu">=</span> return <span class="dv">1797</span> <span class="fu">:&lt;|&gt;</span> ask</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">readerServer ::</span> <span class="dt">Server</span> <span class="dt">ReaderAPI</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">readerServer <span class="fu">=</span> enter (<span class="dt">Nat</span> <span class="fu">$</span> return <span class="fu">.</span> (<span class="ot">`runReader`</span> <span class="st">&quot;hi&quot;</span>)) readerServerT</a></code></pre></div>
<p>The new <code>ServerT</code> type synonym takes an extra paramer that represents what datatype/monad you are using over your handlers (instead of <code>EitherT ServantErr IO</code>).</p>
<p>(Note that we also provide a number of pre-existing <code>Nat</code>s, which are an instance of <code>Category</code>. We could have used</p>
<pre><code>readerServer = enter (generalizeNat . (runReaderTNat &quot;hi&quot;)) readerServerT</code></pre>
<p>instead (with <code>.</code> being from <code>Control.Category</code>).)</p>
<p>Note that the datatypes you can use now don’t even need to be monads!</p>
</section>
<section id="mklink" class="level1">
<h1>mkLink</h1>
<p>Somewhere between the 0.2 release and now, <code>mkLink</code> got a whole lot better (thanks Christian Marie!). <code>mkLink</code> makes urls that are statically guaranteed to belong to your API, without any Template Haskell. Combined with response headers, you can now easily create, for instance, type-safe redirect headers. Combined with the new HTML support, you can easily make links that you know will not 404.</p>
</section>
<section id="left" class="level1">
<h1>Left</h1>
<p>We also changed the default type of handlers from <code>EitherT (Int,String) IO a</code> to <code>EitherT ServantErr IO a</code>. Now it is possible to return headers and a response body in the <code>Left</code> case.</p>
<p>We also now export function <code>errXXX</code> (where <code>XXX</code> is a 300-599 HTTP status code) with sensible reason strings.</p>
</section>
<section id="baseurl" class="level1">
<h1>BaseUrl</h1>
<p>We also changed the <code>client</code> function from <code>servant-client</code> so that, instead of returning various functions that each take a <code>BaseUrl</code> argument (often in inconvenient argument positions), the <code>client</code> function itself takes a <code>BaseUrl</code> argument, and the functions it returns don’t. So the type of <code>client</code> went from</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">client ::</span> <span class="dt">HasClient</span> (<span class="dt">Canonicalize</span> layout) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">Client</span> layout</a></code></pre></div>
<p>To</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">client ::</span> <span class="dt">HasClient</span> (<span class="dt">Canonicalize</span> layout) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">BaseUrl</span> <span class="ot">-&gt;</span> <span class="dt">Client</span> layout</a></code></pre></div>
</section>
<section id="complete-changelogs" class="level1">
<h1>Complete CHANGELOGs</h1>
<ul>
<li><a href="https://github.com/haskell-servant/servant/blob/b81ea9eee200803e764bc924302bb32d7fa81f0f/servant/CHANGELOG.md">servant</a></li>
<li><a href="http://hackage.haskell.org/package/servant-server-0.4.0/changelog">servant-server</a></li>
<li><a href="https://github.com/haskell-servant/servant/blob/b81ea9eee200803e764bc924302bb32d7fa81f0f/servant-client/CHANGELOG.md">servant-client</a></li>
<li><a href="http://hackage.haskell.org/package/servant-docs-0.4.0/changelog">servant-docs</a></li>
<li><a href="http://hackage.haskell.org/package/servant-jquery-0.4.0/changelog">servant-jquery</a></li>
</ul>
</section>
<section id="website" class="level1">
<h1>Website</h1>
<p>We also decided to switch to hakyll in order to be able to have a blog as well as some static pages that collect tips and tricks that people have found. We also used this opportunity to rewrite the getting started into a more informative tutorial, now available <a href="/tutorial">here</a>.</p>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
<p>As you can see, more and more information is getting encoded statically - the types are becoming a pretty rich DSL. In order to keep the noise down, do what you normally do: abstract away common patterns! If your endpoints always return the same content-types, make aliases:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Get&#39;</span> a <span class="fu">=</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>, <span class="dt">HTML</span>, <span class="dt">PlainText</span>] a</a></code></pre></div>
<p>There’s still an outstanding issue with the errors servant returns when a request doesn’t get handled. For example, if the path of a request, but not the method nor the request body, match, rather than returning a 405 (Method Not Allowed) we return a 400 (Bad Request), which is not the desired behavior. Andres Löh made some great suggestions for how to improve our routing time complexity, and hopefully we can integrate a fix for this issue when we tackle that.</p>
<p>We also merged our repos into <a href="https://github.com/haskell-servant/servant">servant</a>. Please use that repo exclusively for PRs and issues (we’ll get rid of the others eventually).</p>
<p>Special thanks to <a href="https://github.com/anchor">the Anchor team</a> from Australia, <a href="https://github.com/mpickering">Matthew Pickering</a>, <a href="https://github.com/dlarsson">Daniel Larsson</a>, <a href="https://github.com/paf31">Phil Freeman</a>, <a href="https://github.com/fisx">Matthias Fischmann</a>, <a href="https://github.com/rschatz">rschatz</a>, <a href="https://github.com/Fuuzetsu">Mateusz Kowalczyk</a>, <a href="https://github.com/codedmart">Brandon Martin</a> and <a href="https://github.com/spl">Sean Leather</a> who’ve contributed from little fixes to whole new features. Several companies are now running <em>servant</em>-powered web applications.</p>
</section>

<div class="post-info">
    Posted on May 10, 2015
    
        by The servant team
    
</div>
]]></description>
    <pubDate>Sun, 10 May 2015 00:00:00 UT</pubDate>
    <guid>http://haskell-servant.github.io/posts/2015-05-10-servant-0.4-released.html</guid>
    <dc:creator>servant developers</dc:creator>
</item>

    </channel>
</rss>
