<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>A web API as a type - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">servant</a>
            </div>
            <div id="navigation">
                <a href="../../">Home</a>
                <a href="../../blog.html">Blog</a>
                <a href="https://haskell-servant.readthedocs.io/en/stable/tutorial/index.html">Tutorial</a>
                <a href="https://haskell-servant.readthedocs.io/en/stable/cookbook/index.html">Cookbook</a>
                <a href="../../talks.html">Talks</a>
                <a href="https://github.com/haskell-servant/servant">GitHub</a>
            </div>
        </div>

        <div id="content">
            <h1>A web API as a type</h1>

            <div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#combinators">Combinators</a><ul>
<li><a href="#static-strings">Static strings</a></li>
<li><a href="#delete-get-patch-post-and-put"><code>Delete</code>, <code>Get</code>, <code>Patch</code>, <code>Post</code> and <code>Put</code></a></li>
<li><a href="#capture"><code>Capture</code></a></li>
<li><a href="#queryparam-queryparams-queryflag-matrixparam-matrixparams-and-matrixflag"><code>QueryParam</code>, <code>QueryParams</code>, <code>QueryFlag</code>, <code>MatrixParam</code>, <code>MatrixParams</code> and <code>MatrixFlag</code></a></li>
<li><a href="#reqbody"><code>ReqBody</code></a></li>
<li><a href="#request-headers">Request <code>Header</code>s</a></li>
<li><a href="#content-types">Content types</a></li>
<li><a href="#response-headers">Response <code>Headers</code></a></li>
<li><a href="#interoperability-with-other-wai-applications-raw">Interoperability with other WAI <code>Application</code>s: <code>Raw</code></a></li>
</ul></li>
</ul></div>
<p>The source for this tutorial section is a literate haskell file, so first we need to have some language extensions and imports:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">module</span> <span class="dt">ApiType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Text</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Servant.API</span></a></code></pre></div>
<p>Consider the following informal specification of an API:</p>
<blockquote>
<p>The endpoint at <code>/users</code> expects a GET request with query string parameter <code>sortby</code> whose value can be one of <code>age</code> or <code>name</code> and returns a list/array of JSON objects describing users, with fields <code>age</code>, <code>name</code>, <code>email</code>, <code>registration_date</code>&quot;.</p>
</blockquote>
<p>You <em>should</em> be able to formalize that. And then use the formalized version to get you much of the way towards writing a web app. And all the way towards getting some client libraries, and documentation (and in the future, who knows - tests, HATEOAS, …).</p>
<p>How would we describe it with servant? As mentioned earlier, an endpoint description is a good old Haskell <strong>type</strong>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;sortby&quot;</span> <span class="dt">SortBy</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">data</span> <span class="dt">SortBy</span> <span class="fu">=</span> <span class="dt">Age</span> <span class="fu">|</span> <span class="dt">Name</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span> {</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">  name ::</span> <span class="dt">String</span>,</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ot">  age ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">}</a></code></pre></div>
<p>Let’s break that down:</p>
<ul>
<li><code>&quot;users&quot;</code> says that our endpoint will be accessible under <code>/users</code>;</li>
<li><code>QueryParam &quot;sortby&quot; SortBy</code>, where <code>SortBy</code> is defined by <code>data SortBy = Age | Name</code>, says that the endpoint has a query string parameter named <code>sortby</code> whose value will be extracted as a value of type <code>SortBy</code>.</li>
<li><code>Get '[JSON] [User]</code> says that the endpoint will be accessible through HTTP GET requests, returning a list of users encoded as JSON. You will see later how you can make use of this to make your data available under different formats, the choice being made depending on the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">Accept header</a> specified in the client’s request.</li>
<li>the <code>:&gt;</code> operator that separates the various “combinators” just lets you sequence static path fragments, URL captures and other combinators. The ordering only matters for static path fragments and URL captures. <code>&quot;users&quot; :&gt; &quot;list-all&quot; :&gt; Get '[JSON] [User]</code>, equivalent to <code>/users/list-all</code>, is obviously not the same as <code>&quot;list-all&quot; :&gt; &quot;users&quot; :&gt; Get '[JSON] [User]</code>, which is equivalent to <code>/list-all/users</code>. This means that sometimes <code>:&gt;</code> is somehow equivalent to <code>/</code>, but sometimes it just lets you chain another combinator.</li>
</ul>
<p>We can also describe APIs with multiple endpoints by using the <code>:&lt;|&gt;</code> combinators. Here’s an example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI2</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="st">&quot;list-all&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">           <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;list-all&quot;</span> <span class="fu">:&gt;</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a></code></pre></div>
<p><em>servant</em> provides a fair amount of combinators out-of-the-box, but you can always write your own when you need it. Here’s a quick overview of all the combinators that servant comes with.</p>
<section id="combinators" class="level1">
<h1>Combinators</h1>
<section id="static-strings" class="level2">
<h2>Static strings</h2>
<p>As you’ve already seen, you can use type-level strings (enabled with the <code>DataKinds</code> language extension) for static path fragments. Chaining them amounts to <code>/</code>-separating them in a URL.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI3</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="st">&quot;list-all&quot;</span> <span class="fu">:&gt;</span> <span class="st">&quot;now&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">              <span class="co">-- describes an endpoint reachable at:</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">              <span class="co">-- /users/list-all/now</span></a></code></pre></div>
</section>
<section id="delete-get-patch-post-and-put" class="level2">
<h2><code>Delete</code>, <code>Get</code>, <code>Patch</code>, <code>Post</code> and <code>Put</code></h2>
<p>These 5 combinators are very similar except that they each describe a different HTTP method. This is how they’re declared</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Delete</span> (<span class="ot">contentTypes ::</span> [<span class="fu">*</span>]) a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Get</span> (<span class="ot">contentTypes ::</span> [<span class="fu">*</span>]) a</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Patch</span> (<span class="ot">contentTypes ::</span> [<span class="fu">*</span>]) a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Post</span> (<span class="ot">contentTypes ::</span> [<span class="fu">*</span>]) a</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Put</span> (<span class="ot">contentTypes ::</span> [<span class="fu">*</span>]) a</a></code></pre></div>
<p>An endpoint ends with one of the 5 combinators above (unless you write your own). Examples:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI4</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">           <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;admins&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a></code></pre></div>
</section>
<section id="capture" class="level2">
<h2><code>Capture</code></h2>
<p>URL captures are parts of the URL that are variable and whose actual value is captured and passed to the request handlers. In many web frameworks, you’ll see it written as in <code>/users/:userid</code>, with that leading <code>:</code> denoting that <code>userid</code> is just some kind of variable name or placeholder. For instance, if <code>userid</code> is supposed to range over all integers greater or equal to 1, our endpoint will match requests made to <code>/users/1</code>, <code>/users/143</code> and so on.</p>
<p>The <code>Capture</code> combinator in servant takes a (type-level) string representing the “name of the variable” and a type, which indicates the type we want to decode the “captured value” to.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Capture</span> (<span class="ot">s ::</span> <span class="dt">Symbol</span>) a</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">-- s :: Symbol just says that 's' must be a type-level string.</span></a></code></pre></div>
<p>In some web frameworks, you use regexes for captures. We use a <a href="https://hackage.haskell.org/package/servant/docs/Servant-Common-Text.html#t:FromText"><code>FromText</code></a> class, which the captured value must be an instance of.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI5</span> <span class="fu">=</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;userid&quot;</span> <span class="dt">Integer</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] <span class="dt">User</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">                <span class="co">-- equivalent to 'GET /user/:userid'</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">                <span class="co">-- except that we explicitly say that &quot;userid&quot;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                <span class="co">-- must be an integer</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">           <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;userid&quot;</span> <span class="dt">Integer</span> <span class="fu">:&gt;</span> <span class="dt">Delete</span> '[] ()</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                <span class="co">-- equivalent to 'DELETE /user/:userid'</span></a></code></pre></div>
</section>
<section id="queryparam-queryparams-queryflag-matrixparam-matrixparams-and-matrixflag" class="level2">
<h2><code>QueryParam</code>, <code>QueryParams</code>, <code>QueryFlag</code>, <code>MatrixParam</code>, <code>MatrixParams</code> and <code>MatrixFlag</code></h2>
<p><code>QueryParam</code>, <code>QueryParams</code> and <code>QueryFlag</code> are about query string parameters, i.e., those parameters that come after the question mark (<code>?</code>) in URLs, like <code>sortby</code> in <code>/users?sortby=age</code>, whose value is set to <code>age</code>. <code>QueryParams</code> lets you specify that the query parameter is actually a list of values, which can be specified using <code>?param[]=value1&amp;param[]=value2</code>. This represents a list of values composed of <code>value1</code> and <code>value2</code>. <code>QueryFlag</code> lets you specify a boolean-like query parameter where a client isn’t forced to specify a value. The absence or presence of the parameter’s name in the query string determines whether the parameter is considered to have the value <code>True</code> or <code>False</code>. For instance, <code>/users?active</code> would list only active users whereas <code>/users</code> would list them all.</p>
<p>Here are the corresponding data type declarations:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">QueryParam</span> (<span class="ot">sym ::</span> <span class="dt">Symbol</span>) a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> <span class="dt">QueryParams</span> (<span class="ot">sym ::</span> <span class="dt">Symbol</span>) a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">data</span> <span class="dt">QueryFlag</span> (<span class="ot">sym ::</span> <span class="dt">Symbol</span>)</a></code></pre></div>
<p><a href="http://www.w3.org/DesignIssues/MatrixURIs.html">Matrix parameters</a> are similar to query string parameters, but they can appear anywhere in the paths (click the link for more details). A URL with matrix parameters in it looks like <code>/users;sortby=age</code>, as opposed to <code>/users?sortby=age</code> with query string parameters. The big advantage is that they are not necessarily at the end of the URL. You could have <code>/users;active=true;registered_after=2005-01-01/locations</code> to get geolocation data about users whom are still active and registered after <em>January 1st, 2005</em>.</p>
<p>Corresponding data type declarations below.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">MatrixParam</span> (<span class="ot">sym ::</span> <span class="dt">Symbol</span>) a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">MatrixParams</span> (<span class="ot">sym ::</span> <span class="dt">Symbol</span>) a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">data</span> <span class="dt">MatrixFlag</span> (<span class="ot">sym ::</span> <span class="dt">Symbol</span>)</a></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI6</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;sortby&quot;</span> <span class="dt">SortBy</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">                <span class="co">-- equivalent to 'GET /users?sortby={age, name}'</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">           <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">MatrixParam</span> <span class="st">&quot;sortby&quot;</span> <span class="dt">SortBy</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">                <span class="co">-- equivalent to 'GET /users;sortby={age, name}'</span></a></code></pre></div>
<p>Again, your handlers don’t have to deserialize these things (into, for example, a <code>SortBy</code>). <em>servant</em> takes care of it.</p>
</section>
<section id="reqbody" class="level2">
<h2><code>ReqBody</code></h2>
<p>Each HTTP request can carry some additional data that the server can use in its <em>body</em>, and this data can be encoded in any format – as long as the server understands it. This can be used for example for an endpoint for creating new users: instead of passing each field of the user as a separate query string parameter or something dirty like that, we can group all the data into a JSON object. This has the advantage of supporting nested objects.</p>
<p><em>servant</em>’s <code>ReqBody</code> combinator takes a list of content types in which the data encoded in the request body can be represented and the type of that data. And, as you might have guessed, you don’t have to check the content-type header, and do the deserialization yourself. We do it for you. And return <code>Bad Request</code> or <code>Unsupported Content Type</code> as appropriate.</p>
<p>Here’s the data type declaration for it:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ReqBody</span> (<span class="ot">contentTypes ::</span> [<span class="fu">*</span>]) a</a></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI7</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> '[<span class="dt">JSON</span>] <span class="dt">User</span> <span class="fu">:&gt;</span> <span class="dt">Post</span> '[<span class="dt">JSON</span>] <span class="dt">User</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">                <span class="co">-- - equivalent to 'POST /users' with a JSON object</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">                <span class="co">--   describing a User in the request body</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">                <span class="co">-- - returns a User encoded in JSON</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">           <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;userid&quot;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">                        <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> '[<span class="dt">JSON</span>] <span class="dt">User</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">                        <span class="fu">:&gt;</span> <span class="dt">Put</span> '[<span class="dt">JSON</span>] <span class="dt">User</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">                <span class="co">-- - equivalent to 'PUT /users/:userid' with a JSON</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">                <span class="co">--   object describing a User in the request body</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">                <span class="co">-- - returns a User encoded in JSON</span></a></code></pre></div>
</section>
<section id="request-headers" class="level2">
<h2>Request <code>Header</code>s</h2>
<p>Request headers are used for various purposes, from caching to carrying auth-related data. They consist of a header name and an associated value. An example would be <code>Accept: application/json</code>.</p>
<p>The <code>Header</code> combinator in servant takes a type-level string for the header name and the type to which we want to decode the header’s value (from some textual representation), as illustrated below:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Header</span> (<span class="ot">sym ::</span> <span class="dt">Symbol</span>) a</a></code></pre></div>
<p>Here’s an example where we declare that an endpoint makes use of the <code>User-Agent</code> header which specifies the name of the software/library used by the client to send the request.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI8</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Header</span> <span class="st">&quot;User-Agent&quot;</span> <span class="dt">Text</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a></code></pre></div>
</section>
<section id="content-types" class="level2">
<h2>Content types</h2>
<p>So far, whenever we have used a combinator that carries a list of content types, we’ve always specified <code>'[JSON]</code>. However, <em>servant</em> lets you use several content types, and also lets you define your own content types.</p>
<p>Four content-types are provided out-of-the-box by the core <em>servant</em> package: <code>JSON</code>, <code>PlainText</code>, <code>FormUrlEncoded</code> and <code>OctetStream</code>. If for some obscure reason you wanted one of your endpoints to make your user data available under those 4 formats, you would write the API type as below:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI9</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>, <span class="dt">PlainText</span>, <span class="dt">FormUrlEncoded</span>, <span class="dt">OctetStream</span>] [<span class="dt">User</span>]</a></code></pre></div>
<p>We also provide an HTML content-type, but since there’s no single library that everyone uses, we decided to release 2 packages, <em>servant-lucid</em> and <em>servant-blaze</em>, to provide HTML encoding of your data.</p>
<p>We will further explain how these content types and your data types can play together in the <a href="../../tutorial/0.4/server.html">section about serving an API</a>.</p>
</section>
<section id="response-headers" class="level2">
<h2>Response <code>Headers</code></h2>
<p>Just like an HTTP request, the response generated by a webserver can carry headers too. <em>servant</em> provides a <code>Headers</code> combinator that carries a list of <code>Header</code> and can be used by simply wrapping the “return type” of an endpoint with it.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Headers</span> (<span class="ot">ls ::</span> [<span class="fu">*</span>]) a</a></code></pre></div>
<p>If you want to describe an endpoint that returns a “User-Count” header in each response, you could write it as below:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI10</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] (<span class="dt">Headers</span> '[<span class="dt">Header</span> <span class="st">&quot;User-Count&quot;</span> <span class="dt">Integer</span>] [<span class="dt">User</span>])</a></code></pre></div>
</section>
<section id="interoperability-with-other-wai-applications-raw" class="level2">
<h2>Interoperability with other WAI <code>Application</code>s: <code>Raw</code></h2>
<p>Finally, we also include a combinator named <code>Raw</code> that can be used for two reasons:</p>
<ul>
<li>You want to serve static files from a given directory. In that case you can just say:</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">type</span> <span class="dt">UserAPI11</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] [<span class="dt">User</span>]</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">                 <span class="co">-- a /users endpoint</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">            <span class="fu">:&lt;|&gt;</span> <span class="dt">Raw</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">                 <span class="co">-- requests to anything else than /users</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">                 <span class="co">-- go here, where the server will try to</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">                 <span class="co">-- find a file with the right name</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">                 <span class="co">-- at the right path</span></a></code></pre></div>
<ul>
<li>You more generally want to plug a <a href="http://hackage.haskell.org/package/wai">WAI <code>Application</code></a> into your webservice. Static file serving is a specific example of that. The API type would look the same as above though. (You can even combine <em>servant</em> with other web frameworks this way!)</li>
</ul>
<div style="text-align: center;">
<p><a href="../../tutorial/0.4/server.html">Next page: Serving an API</a></p>
</div>
</section>
</section>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div>
    </body>
</html>
