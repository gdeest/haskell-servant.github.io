<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Generating documentation from API types - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">servant</a>
            </div>
            <div id="navigation">
                <a href="../../">Home</a>
                <a href="../../blog.html">Blog</a>
                <a href="../../tutorial">Tutorial</a>
                <a href="../../tips.html">Tips and tricks</a>
                <a href="../../talks.html">Talks</a>
                <a href="https://github.com/haskell-servant/servant">Github</a>
            </div>
        </div>

        <div id="content">
            <h1>Generating documentation from API types</h1>

            
<p>The source for this tutorial section is a literate haskell file, so first we need to have some language extensions and imports:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">{-# OPTIONS_GHC -fno-warn-orphans #-}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">module</span> <span class="dt">Docs</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy</span> (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Data.Text.Lazy.Encoding</span> (encodeUtf8)</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Data.Text.Lazy</span> (pack)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="dt">Network.HTTP.Types</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="dt">Network.Wai</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span> <span class="dt">Servant.API</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span> <span class="dt">Servant.Docs</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span> <span class="dt">Servant.Server</span></a></code></pre></div>
<p>And we’ll import some things from one of our earlier modules (<a href="../../tutorial/0.4/server.html">Serving an API</a>):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Server</span> (<span class="dt">Email</span>(..), <span class="dt">ClientInfo</span>(..), <span class="dt">Position</span>(..), <span class="dt">HelloMessage</span>(..),</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  server3, emailForClient)</a></code></pre></div>
<p>Like client function generation, documentation generation amounts to inspecting the API type and extracting all the data we need to then present it in some format to users of your API.</p>
<p>This time however, we have to assist <em>servant</em>. While it is able to deduce a lot of things about our API, it can’t magically come up with descriptions of the various pieces of our APIs that are human-friendly and explain what’s going on “at the business-logic level”. A good example to study for documentation generation is our webservice with the <code>/position</code>, <code>/hello</code> and <code>/marketing</code> endpoints from earlier:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ExampleAPI</span> <span class="fu">=</span> <span class="st">&quot;position&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;x&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;y&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] <span class="dt">Position</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] <span class="dt">HelloMessage</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;marketing&quot;</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> '[<span class="dt">JSON</span>] <span class="dt">ClientInfo</span> <span class="fu">:&gt;</span> <span class="dt">Post</span> '[<span class="dt">JSON</span>] <span class="dt">Email</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">exampleAPI ::</span> <span class="dt">Proxy</span> <span class="dt">ExampleAPI</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">exampleAPI <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>While <em>servant</em> can see e.g. that there are 3 endpoints and that the response bodies will be in JSON, it doesn’t know what influence the captures, parameters, request bodies and other combinators have on the webservice. This is where some manual work is required.</p>
<p>For every capture, request body, response body, query param, we have to give some explanations about how it influences the response, what values are possible and the likes. Here’s how it looks like for the parameters we have above.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">ToCapture</span> (<span class="dt">Capture</span> <span class="st">&quot;x&quot;</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  toCapture _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="dt">DocCapture</span> <span class="st">&quot;x&quot;</span>                                <span class="co">-- name</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">               <span class="st">&quot;(integer) position on the x axis&quot;</span> <span class="co">-- description</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">ToCapture</span> (<span class="dt">Capture</span> <span class="st">&quot;y&quot;</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  toCapture _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="dt">DocCapture</span> <span class="st">&quot;y&quot;</span>                                <span class="co">-- name</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">               <span class="st">&quot;(integer) position on the y axis&quot;</span> <span class="co">-- description</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">Position</span> <span class="dt">Position</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  toSample _ <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Position</span> <span class="dv">3</span> <span class="dv">14</span>) <span class="co">-- example of output</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">ToParam</span> (<span class="dt">QueryParam</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  toParam _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="dt">DocQueryParam</span> <span class="st">&quot;name&quot;</span>                     <span class="co">-- name</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">                  [<span class="st">&quot;Alp&quot;</span>, <span class="st">&quot;John Doe&quot;</span>, <span class="st">&quot;...&quot;</span>] <span class="co">-- example of values (not necessarily exhaustive)</span></a>
<a class="sourceLine" id="cb4-18" data-line-number="18">                  <span class="st">&quot;Name of the person to say hello to.&quot;</span> <span class="co">-- description</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">                  <span class="dt">Normal</span> <span class="co">-- Normal, List or Flag</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">HelloMessage</span> <span class="dt">HelloMessage</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  toSamples _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">    [ (<span class="st">&quot;When a value is provided for 'name'&quot;</span>, <span class="dt">HelloMessage</span> <span class="st">&quot;Hello, Alp&quot;</span>)</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">    , (<span class="st">&quot;When 'name' is not specified&quot;</span>, <span class="dt">HelloMessage</span> <span class="st">&quot;Hello, anonymous coward&quot;</span>)</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">    ]</a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    <span class="co">-- mutliple examples to display this time</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27"></a>
<a class="sourceLine" id="cb4-28" data-line-number="28"><span class="ot">ci ::</span> <span class="dt">ClientInfo</span></a>
<a class="sourceLine" id="cb4-29" data-line-number="29">ci <span class="fu">=</span> <span class="dt">ClientInfo</span> <span class="st">&quot;Alp&quot;</span> <span class="st">&quot;alp@foo.com&quot;</span> <span class="dv">26</span> [<span class="st">&quot;haskell&quot;</span>, <span class="st">&quot;mathematics&quot;</span>]</a>
<a class="sourceLine" id="cb4-30" data-line-number="30"></a>
<a class="sourceLine" id="cb4-31" data-line-number="31"><span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">ClientInfo</span> <span class="dt">ClientInfo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">  toSample _ <span class="fu">=</span> <span class="dt">Just</span> ci</a>
<a class="sourceLine" id="cb4-33" data-line-number="33"></a>
<a class="sourceLine" id="cb4-34" data-line-number="34"><span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">Email</span> <span class="dt">Email</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-35" data-line-number="35">  toSample _ <span class="fu">=</span> <span class="dt">Just</span> (emailForClient ci)</a></code></pre></div>
<p>Types that are used as request or response bodies have to instantiate the <code>ToSample</code> typeclass which lets you specify one or more examples of values. <code>Capture</code>s and <code>QueryParam</code>s have to instantiate their respective <code>ToCapture</code> and <code>ToParam</code> classes and provide a name and some information about the concrete meaning of that argument, as illustrated in the code above.</p>
<p>With all of this, we can derive docs for our API.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">apiDocs ::</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">apiDocs <span class="fu">=</span> docs exampleAPI</a></code></pre></div>
<p><code>API</code> is a type provided by <em>servant-docs</em> that stores all the information one needs about a web API in order to generate documentation in some format. Out of the box, <em>servant-docs</em> only provides a pretty documentation printer that outputs <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a>, but the <a href="http://hackage.haskell.org/package/servant-pandoc">servant-pandoc</a> package can be used to target many useful formats.</p>
<p><em>servant</em>’s markdown pretty printer is a function named <code>markdown</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">markdown ::</span> <span class="dt">API</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<p>That lets us see what our API docs look down in markdown, by looking at <code>markdown apiDocs</code>.</p>
<p>``` text ## Welcome</p>
<p>This is our super webservice’s API.</p>
<p>Enjoy!</p>
<p>## GET /hello</p>
<p>#### GET Parameters:</p>
<ul>
<li>name
<ul>
<li><strong>Values</strong>: <em>Alp, John Doe, …</em></li>
<li><strong>Description</strong>: Name of the person to say hello to.</li>
</ul></li>
</ul>
<p>#### Response:</p>
<ul>
<li>Status code 200</li>
<li><p>Headers: []</p></li>
<li><p>Supported content types are:</p>
<ul>
<li><code>application/json</code></li>
</ul></li>
<li><p>When a value is provided for ‘name’</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="op">{</span><span class="st">&quot;msg&quot;</span><span class="op">:</span><span class="st">&quot;Hello, Alp&quot;</span><span class="op">}</span></a></code></pre></div></li>
<li><p>When ‘name’ is not specified</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="op">{</span><span class="st">&quot;msg&quot;</span><span class="op">:</span><span class="st">&quot;Hello, anonymous coward&quot;</span><span class="op">}</span></a></code></pre></div></li>
</ul>
<p>## POST /marketing</p>
<p>#### Request:</p>
<ul>
<li><p>Supported content types are:</p>
<ul>
<li><code>application/json</code></li>
</ul></li>
<li><p>Example: <code>application/json</code></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="op">{</span><span class="st">&quot;email&quot;</span><span class="op">:</span><span class="st">&quot;alp@foo.com&quot;</span><span class="op">,</span><span class="st">&quot;interested_in&quot;</span><span class="op">:</span>[<span class="st">&quot;haskell&quot;</span><span class="op">,</span><span class="st">&quot;mathematics&quot;</span>]<span class="op">,</span><span class="st">&quot;age&quot;</span><span class="op">:</span><span class="dv">26</span><span class="op">,</span><span class="st">&quot;name&quot;</span><span class="op">:</span><span class="st">&quot;Alp&quot;</span><span class="op">}</span></a></code></pre></div></li>
</ul>
<p>#### Response:</p>
<ul>
<li>Status code 201</li>
<li><p>Headers: []</p></li>
<li><p>Supported content types are:</p>
<ul>
<li><code>application/json</code></li>
</ul></li>
<li><p>Response body as below.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="op">{</span><span class="st">&quot;subject&quot;</span><span class="op">:</span><span class="st">&quot;Hey Alp, we miss you!&quot;</span><span class="op">,</span><span class="st">&quot;body&quot;</span><span class="op">:</span><span class="st">&quot;Hi Alp,</span><span class="sc">\n\n</span><span class="st">Since you've recently turned 26, have you checked out our latest haskell, mathematics products? Give us a visit!&quot;</span><span class="op">,</span><span class="st">&quot;to&quot;</span><span class="op">:</span><span class="st">&quot;alp@foo.com&quot;</span><span class="op">,</span><span class="st">&quot;from&quot;</span><span class="op">:</span><span class="st">&quot;great@company.com&quot;</span><span class="op">}</span></a></code></pre></div></li>
</ul>
<p>## GET /position/:x/:y</p>
<p>#### Captures:</p>
<ul>
<li><em>x</em>: (integer) position on the x axis</li>
<li><em>y</em>: (integer) position on the y axis</li>
</ul>
<p>#### Response:</p>
<ul>
<li>Status code 200</li>
<li><p>Headers: []</p></li>
<li><p>Supported content types are:</p>
<ul>
<li><code>application/json</code></li>
</ul></li>
<li><p>Response body as below.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="op">{</span><span class="st">&quot;x&quot;</span><span class="op">:</span><span class="dv">3</span><span class="op">,</span><span class="st">&quot;y&quot;</span><span class="op">:</span><span class="dv">14</span><span class="op">}</span></a></code></pre></div></li>
</ul>
<p>```</p>
<p>However, we can also add one or more introduction sections to the document. We just need to tweak the way we generate <code>apiDocs</code>. We will also convert the content to a lazy <code>ByteString</code> since this is what <em>wai</em> expects for <code>Raw</code> endpoints.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">docsBS ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">docsBS <span class="fu">=</span> encodeUtf8</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">       <span class="fu">.</span> pack</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">       <span class="fu">.</span> markdown</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">       <span class="fu">$</span> docsWithIntros [intro] exampleAPI</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  <span class="kw">where</span> intro <span class="fu">=</span> <span class="dt">DocIntro</span> <span class="st">&quot;Welcome&quot;</span> [<span class="st">&quot;This is our super webservice's API.&quot;</span>, <span class="st">&quot;Enjoy!&quot;</span>]</a></code></pre></div>
<p><code>docsWithIntros</code> just takes an additional parameter, a list of <code>DocIntro</code>s that must be displayed before any endpoint docs.</p>
<p>We can now serve the API <em>and</em> the API docs with a simple server.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">type</span> <span class="dt">DocsAPI</span> <span class="fu">=</span> <span class="dt">ExampleAPI</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">Raw</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">DocsAPI</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">api <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">DocsAPI</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">server <span class="fu">=</span> Server.server3 <span class="fu">:&lt;|&gt;</span> serveDocs</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  <span class="kw">where</span> serveDocs _ respond <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">          respond <span class="fu">$</span> responseLBS ok200 [plain] docsBS</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">        plain <span class="fu">=</span> (<span class="st">&quot;Content-Type&quot;</span>, <span class="st">&quot;text/plain&quot;</span>)</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="ot">app ::</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15">app <span class="fu">=</span> serve api server</a></code></pre></div>
<p>And if you spin up this server with <code>dist/build/tutorial/tutorial 10</code> and go to anywhere else than <code>/position</code>, <code>/hello</code> and <code>/marketing</code>, you will see the API docs in markdown. This is because <code>serveDocs</code> is attempted if the 3 other endpoints don’t match and systematically succeeds since its definition is to just return some fixed bytestring with the <code>text/plain</code> content type.</p>
<div style="text-align: center;">
<p><a href="../../tutorial/0.4/javascript.html">Previous page: Generating javascript functions to query an API</a></p>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div>
    </body>
</html>
